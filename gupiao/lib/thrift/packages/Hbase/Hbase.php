<?php
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
include_once $GLOBALS['THRIFT_ROOT'].'/Thrift.php';

include_once $GLOBALS['THRIFT_ROOT'].'/packages/Hbase/Hbase_types.php';

interface HbaseIf {
  public function enableTable($tableName);
  public function disableTable($tableName);
  public function isTableEnabled($tableName);
  public function compact($tableNameOrRegionName);
  public function majorCompact($tableNameOrRegionName);
  public function getTableNames();
  public function getColumnDescriptors($tableName);
  public function getTableRegions($tableName);
  public function createTable($tableName, $columnFamilies);
  public function createTableForYuntu($clusterInfo, $tableName, $colDesc, $userName);
  public function deleteTable($tableName);
  public function deleteTableForYuntu($clusterInfo, $tableName, $userName);
  public function isDeleteTableDoneForYuntu($id);
  public function get($tableName, $row, $column);
  public function getVer($tableName, $row, $column, $numVersions);
  public function getVerTs($tableName, $row, $column, $timestamp, $numVersions);
  public function getRow($tableName, $row);
  public function getRowWithColumns($tableName, $row, $columns);
  public function getRowTs($tableName, $row, $timestamp);
  public function getRowWithColumnsTs($tableName, $row, $columns, $timestamp);
  public function getRowWithColumnsTsRange($tableName, $row, $columns, $minTs, $maxTs);
  public function getRowWithColumnPrefix($tableName, $row, $prefix);
  public function getRowWithColumnPrefixTs($tableName, $row, $prefix, $timestamp);
  public function getRows($tableName, $rows);
  public function getRowsTs($tableName, $rows, $timestamp);
  public function getRowsWithColumns($tableName, $rows, $families);
  public function getRowsWithColumnsTs($tableName, $rows, $families, $timestamp);
  public function mutateRow($tableName, $row, $mutations);
  public function mutateRowTs($tableName, $row, $mutations, $timestamp);
  public function mutateRows($tableName, $rowBatches);
  public function mutateRowsTs($tableName, $rowBatches, $timestamp);
  public function checkAndMutateRow($tableName, $row, $columnCheck, $valueCheck, $mutations);
  public function checkAndMutateRowTs($tableName, $row, $columnCheck, $valueCheck, $mutations, $timestamp);
  public function atomicIncrement($tableName, $row, $column, $value);
  public function deleteAll($tableName, $row, $column);
  public function deleteAllTs($tableName, $row, $column, $timestamp);
  public function deleteAllRow($tableName, $row);
  public function deleteAllRowTs($tableName, $row, $timestamp);
  public function scannerOpen($tableName, $startRow, $columns);
  public function scannerOpenWithScan($tableName, $scan);
  public function scannerOpenWithStop($tableName, $startRow, $stopRow, $columns);
  public function scannerOpenWithPrefix($tableName, $startAndPrefix, $columns);
  public function scannerOpenTs($tableName, $startRow, $columns, $timestamp);
  public function scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp);
  public function scannerOpenWithFilterString($tableName, $filterString);
  public function scannerOpenWithFilterStringTs($tableName, $filterString, $timestamp);
  public function scannerOpenWithStopAndFilterString($tableName, $startRow, $stopRow, $filterString);
  public function scannerOpenWithStopAndFilterStringTs($tableName, $startRow, $stopRow, $filterString, $timestamp);
  public function scannerOpenWithIndexAndColumns($tableName, $columns, $expr);
  public function scannerOpenWithIndexExpression($tableName, $columns, $expr);
  public function scannerOpenWithIndexExpressionTs($tableName, $columns, $expr, $timestamp);
  public function scannerOpenWithStopAndIndexExpression($tableName, $startRow, $stopRow, $columns, $expr);
  public function scannerOpenWithStopAndIndexExpressionTs($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs);
  public function aggTopN($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs, $topnColumns, $topnN, $topnMaxN, $isDesc);
  public function aggRowNum($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs);
  public function aggFacetingByTimestamp($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs, $startTs, $endTs, $intervalTs);
  public function getTableIndexDesc($tableName);
  public function miniScanWithScan($tableName, $scan);
  public function miniScanWithStop($tableName, $startRow, $stopRow, $columns);
  public function miniScanWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp);
  public function miniScanWithIndexExpression($tableName, $columns, $expr);
  public function miniScanWithStopAndIndexExpression($tableName, $startRow, $stopRow, $columns, $expr);
  public function miniScanWithIndexExpressionTs($tableName, $columns, $expr, $timestamp);
  public function miniScanWithStopAndIndexExpressionTs($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs);
  public function searchMaxScoreResult($tableName, $startRow, $stopRow, $columns, $expr, $count, $minTs, $maxTs);
  public function scannerGet($id);
  public function scannerGetList($id, $nbRows);
  public function scannerGetListByJson($id, $nbRows);
  public function scannerClose($id);
  public function getRegionInfo($row);
  public function QstoreBatchRead($columnstore_list);
  public function QstoreBatchReadDigest($columnstore_list);
  public function QstoreBatchWrite($columnstore_list);
  public function QstoreMultiRead($keystore_list, $consistency_level);
  public function QstoreMultiReadDigest($keystore_list, $consistency_level);
  public function QstoreMultiWrite($keystore_list, $consistency_level);
  public function QstoreMultiDelete($keystore_list, $consistency_level);
  public function InnerMultiRead($keystore_list, $consistency_level);
  public function InnerMultiReadDigest($keystore_list, $consistency_level);
  public function InnerMultiWrite($keystore_list, $consistency_level);
  public function TransferMultiWrite($keystore_list, $consistency_level);
  public function InnerMultiDelete($keystore_list, $consistency_level);
}

class HbaseClient implements HbaseIf {
  protected $input_ = null;
  protected $output_ = null;

  protected $seqid_ = 0;

  public function __construct($input, $output=null) {
    $this->input_ = $input;
    $this->output_ = $output ? $output : $input;
  }

  public function enableTable($tableName)
  {
    $this->send_enableTable($tableName);
    $this->recv_enableTable();
  }

  public function send_enableTable($tableName)
  {
    $args = new Hbase_enableTable_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'enableTable', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('enableTable', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_enableTable()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_enableTable_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_enableTable_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function disableTable($tableName)
  {
    $this->send_disableTable($tableName);
    $this->recv_disableTable();
  }

  public function send_disableTable($tableName)
  {
    $args = new Hbase_disableTable_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'disableTable', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('disableTable', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_disableTable()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_disableTable_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_disableTable_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function isTableEnabled($tableName)
  {
    $this->send_isTableEnabled($tableName);
    return $this->recv_isTableEnabled();
  }

  public function send_isTableEnabled($tableName)
  {
    $args = new Hbase_isTableEnabled_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'isTableEnabled', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('isTableEnabled', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_isTableEnabled()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_isTableEnabled_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_isTableEnabled_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("isTableEnabled failed: unknown result");
  }

  public function compact($tableNameOrRegionName)
  {
    $this->send_compact($tableNameOrRegionName);
    $this->recv_compact();
  }

  public function send_compact($tableNameOrRegionName)
  {
    $args = new Hbase_compact_args();
    $args->tableNameOrRegionName = $tableNameOrRegionName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'compact', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('compact', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_compact()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_compact_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_compact_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function majorCompact($tableNameOrRegionName)
  {
    $this->send_majorCompact($tableNameOrRegionName);
    $this->recv_majorCompact();
  }

  public function send_majorCompact($tableNameOrRegionName)
  {
    $args = new Hbase_majorCompact_args();
    $args->tableNameOrRegionName = $tableNameOrRegionName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'majorCompact', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('majorCompact', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_majorCompact()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_majorCompact_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_majorCompact_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function getTableNames()
  {
    $this->send_getTableNames();
    return $this->recv_getTableNames();
  }

  public function send_getTableNames()
  {
    $args = new Hbase_getTableNames_args();
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTableNames', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTableNames', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTableNames()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getTableNames_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getTableNames_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getTableNames failed: unknown result");
  }

  public function getColumnDescriptors($tableName)
  {
    $this->send_getColumnDescriptors($tableName);
    return $this->recv_getColumnDescriptors();
  }

  public function send_getColumnDescriptors($tableName)
  {
    $args = new Hbase_getColumnDescriptors_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getColumnDescriptors', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getColumnDescriptors', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getColumnDescriptors()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getColumnDescriptors_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getColumnDescriptors_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getColumnDescriptors failed: unknown result");
  }

  public function getTableRegions($tableName)
  {
    $this->send_getTableRegions($tableName);
    return $this->recv_getTableRegions();
  }

  public function send_getTableRegions($tableName)
  {
    $args = new Hbase_getTableRegions_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTableRegions', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTableRegions', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTableRegions()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getTableRegions_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getTableRegions_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getTableRegions failed: unknown result");
  }

  public function createTable($tableName, $columnFamilies)
  {
    $this->send_createTable($tableName, $columnFamilies);
    $this->recv_createTable();
  }

  public function send_createTable($tableName, $columnFamilies)
  {
    $args = new Hbase_createTable_args();
    $args->tableName = $tableName;
    $args->columnFamilies = $columnFamilies;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'createTable', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('createTable', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_createTable()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_createTable_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_createTable_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    if ($result->exist !== null) {
      throw $result->exist;
    }
    return;
  }

  public function createTableForYuntu($clusterInfo, $tableName, $colDesc, $userName)
  {
    $this->send_createTableForYuntu($clusterInfo, $tableName, $colDesc, $userName);
    $this->recv_createTableForYuntu();
  }

  public function send_createTableForYuntu($clusterInfo, $tableName, $colDesc, $userName)
  {
    $args = new Hbase_createTableForYuntu_args();
    $args->clusterInfo = $clusterInfo;
    $args->tableName = $tableName;
    $args->colDesc = $colDesc;
    $args->userName = $userName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'createTableForYuntu', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('createTableForYuntu', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_createTableForYuntu()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_createTableForYuntu_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_createTableForYuntu_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    if ($result->exist !== null) {
      throw $result->exist;
    }
    return;
  }

  public function deleteTable($tableName)
  {
    $this->send_deleteTable($tableName);
    $this->recv_deleteTable();
  }

  public function send_deleteTable($tableName)
  {
    $args = new Hbase_deleteTable_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteTable', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteTable', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteTable()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_deleteTable_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_deleteTable_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function deleteTableForYuntu($clusterInfo, $tableName, $userName)
  {
    $this->send_deleteTableForYuntu($clusterInfo, $tableName, $userName);
    return $this->recv_deleteTableForYuntu();
  }

  public function send_deleteTableForYuntu($clusterInfo, $tableName, $userName)
  {
    $args = new Hbase_deleteTableForYuntu_args();
    $args->clusterInfo = $clusterInfo;
    $args->tableName = $tableName;
    $args->userName = $userName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteTableForYuntu', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteTableForYuntu', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteTableForYuntu()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_deleteTableForYuntu_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_deleteTableForYuntu_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new Exception("deleteTableForYuntu failed: unknown result");
  }

  public function isDeleteTableDoneForYuntu($id)
  {
    $this->send_isDeleteTableDoneForYuntu($id);
    return $this->recv_isDeleteTableDoneForYuntu();
  }

  public function send_isDeleteTableDoneForYuntu($id)
  {
    $args = new Hbase_isDeleteTableDoneForYuntu_args();
    $args->id = $id;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'isDeleteTableDoneForYuntu', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('isDeleteTableDoneForYuntu', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_isDeleteTableDoneForYuntu()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_isDeleteTableDoneForYuntu_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_isDeleteTableDoneForYuntu_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("isDeleteTableDoneForYuntu failed: unknown result");
  }

  public function get($tableName, $row, $column)
  {
    $this->send_get($tableName, $row, $column);
    return $this->recv_get();
  }

  public function send_get($tableName, $row, $column)
  {
    $args = new Hbase_get_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'get', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('get', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_get()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_get_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_get_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("get failed: unknown result");
  }

  public function getVer($tableName, $row, $column, $numVersions)
  {
    $this->send_getVer($tableName, $row, $column, $numVersions);
    return $this->recv_getVer();
  }

  public function send_getVer($tableName, $row, $column, $numVersions)
  {
    $args = new Hbase_getVer_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->numVersions = $numVersions;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getVer', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getVer', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getVer()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getVer_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getVer_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getVer failed: unknown result");
  }

  public function getVerTs($tableName, $row, $column, $timestamp, $numVersions)
  {
    $this->send_getVerTs($tableName, $row, $column, $timestamp, $numVersions);
    return $this->recv_getVerTs();
  }

  public function send_getVerTs($tableName, $row, $column, $timestamp, $numVersions)
  {
    $args = new Hbase_getVerTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->timestamp = $timestamp;
    $args->numVersions = $numVersions;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getVerTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getVerTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getVerTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getVerTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getVerTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getVerTs failed: unknown result");
  }

  public function getRow($tableName, $row)
  {
    $this->send_getRow($tableName, $row);
    return $this->recv_getRow();
  }

  public function send_getRow($tableName, $row)
  {
    $args = new Hbase_getRow_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRow', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRow', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRow()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRow_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRow_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRow failed: unknown result");
  }

  public function getRowWithColumns($tableName, $row, $columns)
  {
    $this->send_getRowWithColumns($tableName, $row, $columns);
    return $this->recv_getRowWithColumns();
  }

  public function send_getRowWithColumns($tableName, $row, $columns)
  {
    $args = new Hbase_getRowWithColumns_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->columns = $columns;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowWithColumns', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowWithColumns', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowWithColumns()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRowWithColumns_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRowWithColumns_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRowWithColumns failed: unknown result");
  }

  public function getRowTs($tableName, $row, $timestamp)
  {
    $this->send_getRowTs($tableName, $row, $timestamp);
    return $this->recv_getRowTs();
  }

  public function send_getRowTs($tableName, $row, $timestamp)
  {
    $args = new Hbase_getRowTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRowTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRowTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRowTs failed: unknown result");
  }

  public function getRowWithColumnsTs($tableName, $row, $columns, $timestamp)
  {
    $this->send_getRowWithColumnsTs($tableName, $row, $columns, $timestamp);
    return $this->recv_getRowWithColumnsTs();
  }

  public function send_getRowWithColumnsTs($tableName, $row, $columns, $timestamp)
  {
    $args = new Hbase_getRowWithColumnsTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->columns = $columns;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowWithColumnsTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowWithColumnsTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowWithColumnsTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRowWithColumnsTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRowWithColumnsTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRowWithColumnsTs failed: unknown result");
  }

  public function getRowWithColumnsTsRange($tableName, $row, $columns, $minTs, $maxTs)
  {
    $this->send_getRowWithColumnsTsRange($tableName, $row, $columns, $minTs, $maxTs);
    return $this->recv_getRowWithColumnsTsRange();
  }

  public function send_getRowWithColumnsTsRange($tableName, $row, $columns, $minTs, $maxTs)
  {
    $args = new Hbase_getRowWithColumnsTsRange_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->columns = $columns;
    $args->minTs = $minTs;
    $args->maxTs = $maxTs;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowWithColumnsTsRange', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowWithColumnsTsRange', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowWithColumnsTsRange()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRowWithColumnsTsRange_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRowWithColumnsTsRange_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRowWithColumnsTsRange failed: unknown result");
  }

  public function getRowWithColumnPrefix($tableName, $row, $prefix)
  {
    $this->send_getRowWithColumnPrefix($tableName, $row, $prefix);
    return $this->recv_getRowWithColumnPrefix();
  }

  public function send_getRowWithColumnPrefix($tableName, $row, $prefix)
  {
    $args = new Hbase_getRowWithColumnPrefix_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->prefix = $prefix;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowWithColumnPrefix', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowWithColumnPrefix', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowWithColumnPrefix()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRowWithColumnPrefix_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRowWithColumnPrefix_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRowWithColumnPrefix failed: unknown result");
  }

  public function getRowWithColumnPrefixTs($tableName, $row, $prefix, $timestamp)
  {
    $this->send_getRowWithColumnPrefixTs($tableName, $row, $prefix, $timestamp);
    return $this->recv_getRowWithColumnPrefixTs();
  }

  public function send_getRowWithColumnPrefixTs($tableName, $row, $prefix, $timestamp)
  {
    $args = new Hbase_getRowWithColumnPrefixTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->prefix = $prefix;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowWithColumnPrefixTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowWithColumnPrefixTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowWithColumnPrefixTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRowWithColumnPrefixTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRowWithColumnPrefixTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRowWithColumnPrefixTs failed: unknown result");
  }

  public function getRows($tableName, $rows)
  {
    $this->send_getRows($tableName, $rows);
    return $this->recv_getRows();
  }

  public function send_getRows($tableName, $rows)
  {
    $args = new Hbase_getRows_args();
    $args->tableName = $tableName;
    $args->rows = $rows;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRows', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRows', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRows()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRows_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRows_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRows failed: unknown result");
  }

  public function getRowsTs($tableName, $rows, $timestamp)
  {
    $this->send_getRowsTs($tableName, $rows, $timestamp);
    return $this->recv_getRowsTs();
  }

  public function send_getRowsTs($tableName, $rows, $timestamp)
  {
    $args = new Hbase_getRowsTs_args();
    $args->tableName = $tableName;
    $args->rows = $rows;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowsTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowsTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowsTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRowsTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRowsTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRowsTs failed: unknown result");
  }

  public function getRowsWithColumns($tableName, $rows, $families)
  {
    $this->send_getRowsWithColumns($tableName, $rows, $families);
    return $this->recv_getRowsWithColumns();
  }

  public function send_getRowsWithColumns($tableName, $rows, $families)
  {
    $args = new Hbase_getRowsWithColumns_args();
    $args->tableName = $tableName;
    $args->rows = $rows;
    $args->families = $families;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowsWithColumns', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowsWithColumns', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowsWithColumns()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRowsWithColumns_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRowsWithColumns_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRowsWithColumns failed: unknown result");
  }

  public function getRowsWithColumnsTs($tableName, $rows, $families, $timestamp)
  {
    $this->send_getRowsWithColumnsTs($tableName, $rows, $families, $timestamp);
    return $this->recv_getRowsWithColumnsTs();
  }

  public function send_getRowsWithColumnsTs($tableName, $rows, $families, $timestamp)
  {
    $args = new Hbase_getRowsWithColumnsTs_args();
    $args->tableName = $tableName;
    $args->rows = $rows;
    $args->families = $families;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRowsWithColumnsTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRowsWithColumnsTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRowsWithColumnsTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRowsWithColumnsTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRowsWithColumnsTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRowsWithColumnsTs failed: unknown result");
  }

  public function mutateRow($tableName, $row, $mutations)
  {
    $this->send_mutateRow($tableName, $row, $mutations);
    $this->recv_mutateRow();
  }

  public function send_mutateRow($tableName, $row, $mutations)
  {
    $args = new Hbase_mutateRow_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->mutations = $mutations;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mutateRow', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mutateRow', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mutateRow()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_mutateRow_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_mutateRow_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function mutateRowTs($tableName, $row, $mutations, $timestamp)
  {
    $this->send_mutateRowTs($tableName, $row, $mutations, $timestamp);
    $this->recv_mutateRowTs();
  }

  public function send_mutateRowTs($tableName, $row, $mutations, $timestamp)
  {
    $args = new Hbase_mutateRowTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->mutations = $mutations;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mutateRowTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mutateRowTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mutateRowTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_mutateRowTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_mutateRowTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function mutateRows($tableName, $rowBatches)
  {
    $this->send_mutateRows($tableName, $rowBatches);
    $this->recv_mutateRows();
  }

  public function send_mutateRows($tableName, $rowBatches)
  {
    $args = new Hbase_mutateRows_args();
    $args->tableName = $tableName;
    $args->rowBatches = $rowBatches;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mutateRows', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mutateRows', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mutateRows()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_mutateRows_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_mutateRows_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function mutateRowsTs($tableName, $rowBatches, $timestamp)
  {
    $this->send_mutateRowsTs($tableName, $rowBatches, $timestamp);
    $this->recv_mutateRowsTs();
  }

  public function send_mutateRowsTs($tableName, $rowBatches, $timestamp)
  {
    $args = new Hbase_mutateRowsTs_args();
    $args->tableName = $tableName;
    $args->rowBatches = $rowBatches;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'mutateRowsTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('mutateRowsTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_mutateRowsTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_mutateRowsTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_mutateRowsTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function checkAndMutateRow($tableName, $row, $columnCheck, $valueCheck, $mutations)
  {
    $this->send_checkAndMutateRow($tableName, $row, $columnCheck, $valueCheck, $mutations);
    return $this->recv_checkAndMutateRow();
  }

  public function send_checkAndMutateRow($tableName, $row, $columnCheck, $valueCheck, $mutations)
  {
    $args = new Hbase_checkAndMutateRow_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->columnCheck = $columnCheck;
    $args->valueCheck = $valueCheck;
    $args->mutations = $mutations;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'checkAndMutateRow', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('checkAndMutateRow', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_checkAndMutateRow()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_checkAndMutateRow_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_checkAndMutateRow_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new Exception("checkAndMutateRow failed: unknown result");
  }

  public function checkAndMutateRowTs($tableName, $row, $columnCheck, $valueCheck, $mutations, $timestamp)
  {
    $this->send_checkAndMutateRowTs($tableName, $row, $columnCheck, $valueCheck, $mutations, $timestamp);
    return $this->recv_checkAndMutateRowTs();
  }

  public function send_checkAndMutateRowTs($tableName, $row, $columnCheck, $valueCheck, $mutations, $timestamp)
  {
    $args = new Hbase_checkAndMutateRowTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->columnCheck = $columnCheck;
    $args->valueCheck = $valueCheck;
    $args->mutations = $mutations;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'checkAndMutateRowTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('checkAndMutateRowTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_checkAndMutateRowTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_checkAndMutateRowTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_checkAndMutateRowTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new Exception("checkAndMutateRowTs failed: unknown result");
  }

  public function atomicIncrement($tableName, $row, $column, $value)
  {
    $this->send_atomicIncrement($tableName, $row, $column, $value);
    return $this->recv_atomicIncrement();
  }

  public function send_atomicIncrement($tableName, $row, $column, $value)
  {
    $args = new Hbase_atomicIncrement_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->value = $value;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'atomicIncrement', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('atomicIncrement', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_atomicIncrement()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_atomicIncrement_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_atomicIncrement_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new Exception("atomicIncrement failed: unknown result");
  }

  public function deleteAll($tableName, $row, $column)
  {
    $this->send_deleteAll($tableName, $row, $column);
    $this->recv_deleteAll();
  }

  public function send_deleteAll($tableName, $row, $column)
  {
    $args = new Hbase_deleteAll_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteAll', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteAll', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteAll()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_deleteAll_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_deleteAll_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function deleteAllTs($tableName, $row, $column, $timestamp)
  {
    $this->send_deleteAllTs($tableName, $row, $column, $timestamp);
    $this->recv_deleteAllTs();
  }

  public function send_deleteAllTs($tableName, $row, $column, $timestamp)
  {
    $args = new Hbase_deleteAllTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->column = $column;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteAllTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteAllTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteAllTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_deleteAllTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_deleteAllTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function deleteAllRow($tableName, $row)
  {
    $this->send_deleteAllRow($tableName, $row);
    $this->recv_deleteAllRow();
  }

  public function send_deleteAllRow($tableName, $row)
  {
    $args = new Hbase_deleteAllRow_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteAllRow', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteAllRow', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteAllRow()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_deleteAllRow_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_deleteAllRow_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function deleteAllRowTs($tableName, $row, $timestamp)
  {
    $this->send_deleteAllRowTs($tableName, $row, $timestamp);
    $this->recv_deleteAllRowTs();
  }

  public function send_deleteAllRowTs($tableName, $row, $timestamp)
  {
    $args = new Hbase_deleteAllRowTs_args();
    $args->tableName = $tableName;
    $args->row = $row;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'deleteAllRowTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('deleteAllRowTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_deleteAllRowTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_deleteAllRowTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_deleteAllRowTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    return;
  }

  public function scannerOpen($tableName, $startRow, $columns)
  {
    $this->send_scannerOpen($tableName, $startRow, $columns);
    return $this->recv_scannerOpen();
  }

  public function send_scannerOpen($tableName, $startRow, $columns)
  {
    $args = new Hbase_scannerOpen_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->columns = $columns;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpen', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpen', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpen()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpen_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpen_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpen failed: unknown result");
  }

  public function scannerOpenWithScan($tableName, $scan)
  {
    $this->send_scannerOpenWithScan($tableName, $scan);
    return $this->recv_scannerOpenWithScan();
  }

  public function send_scannerOpenWithScan($tableName, $scan)
  {
    $args = new Hbase_scannerOpenWithScan_args();
    $args->tableName = $tableName;
    $args->scan = $scan;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithScan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithScan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithScan()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithScan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithScan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithScan failed: unknown result");
  }

  public function scannerOpenWithStop($tableName, $startRow, $stopRow, $columns)
  {
    $this->send_scannerOpenWithStop($tableName, $startRow, $stopRow, $columns);
    return $this->recv_scannerOpenWithStop();
  }

  public function send_scannerOpenWithStop($tableName, $startRow, $stopRow, $columns)
  {
    $args = new Hbase_scannerOpenWithStop_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithStop', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithStop', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithStop()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithStop_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithStop_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithStop failed: unknown result");
  }

  public function scannerOpenWithPrefix($tableName, $startAndPrefix, $columns)
  {
    $this->send_scannerOpenWithPrefix($tableName, $startAndPrefix, $columns);
    return $this->recv_scannerOpenWithPrefix();
  }

  public function send_scannerOpenWithPrefix($tableName, $startAndPrefix, $columns)
  {
    $args = new Hbase_scannerOpenWithPrefix_args();
    $args->tableName = $tableName;
    $args->startAndPrefix = $startAndPrefix;
    $args->columns = $columns;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithPrefix', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithPrefix', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithPrefix()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithPrefix_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithPrefix_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithPrefix failed: unknown result");
  }

  public function scannerOpenTs($tableName, $startRow, $columns, $timestamp)
  {
    $this->send_scannerOpenTs($tableName, $startRow, $columns, $timestamp);
    return $this->recv_scannerOpenTs();
  }

  public function send_scannerOpenTs($tableName, $startRow, $columns, $timestamp)
  {
    $args = new Hbase_scannerOpenTs_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->columns = $columns;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenTs failed: unknown result");
  }

  public function scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp)
  {
    $this->send_scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp);
    return $this->recv_scannerOpenWithStopTs();
  }

  public function send_scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp)
  {
    $args = new Hbase_scannerOpenWithStopTs_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithStopTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithStopTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithStopTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithStopTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithStopTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithStopTs failed: unknown result");
  }

  public function scannerOpenWithFilterString($tableName, $filterString)
  {
    $this->send_scannerOpenWithFilterString($tableName, $filterString);
    return $this->recv_scannerOpenWithFilterString();
  }

  public function send_scannerOpenWithFilterString($tableName, $filterString)
  {
    $args = new Hbase_scannerOpenWithFilterString_args();
    $args->tableName = $tableName;
    $args->filterString = $filterString;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithFilterString', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithFilterString', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithFilterString()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithFilterString_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithFilterString_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithFilterString failed: unknown result");
  }

  public function scannerOpenWithFilterStringTs($tableName, $filterString, $timestamp)
  {
    $this->send_scannerOpenWithFilterStringTs($tableName, $filterString, $timestamp);
    return $this->recv_scannerOpenWithFilterStringTs();
  }

  public function send_scannerOpenWithFilterStringTs($tableName, $filterString, $timestamp)
  {
    $args = new Hbase_scannerOpenWithFilterStringTs_args();
    $args->tableName = $tableName;
    $args->filterString = $filterString;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithFilterStringTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithFilterStringTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithFilterStringTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithFilterStringTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithFilterStringTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithFilterStringTs failed: unknown result");
  }

  public function scannerOpenWithStopAndFilterString($tableName, $startRow, $stopRow, $filterString)
  {
    $this->send_scannerOpenWithStopAndFilterString($tableName, $startRow, $stopRow, $filterString);
    return $this->recv_scannerOpenWithStopAndFilterString();
  }

  public function send_scannerOpenWithStopAndFilterString($tableName, $startRow, $stopRow, $filterString)
  {
    $args = new Hbase_scannerOpenWithStopAndFilterString_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->filterString = $filterString;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithStopAndFilterString', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithStopAndFilterString', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithStopAndFilterString()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithStopAndFilterString_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithStopAndFilterString_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithStopAndFilterString failed: unknown result");
  }

  public function scannerOpenWithStopAndFilterStringTs($tableName, $startRow, $stopRow, $filterString, $timestamp)
  {
    $this->send_scannerOpenWithStopAndFilterStringTs($tableName, $startRow, $stopRow, $filterString, $timestamp);
    return $this->recv_scannerOpenWithStopAndFilterStringTs();
  }

  public function send_scannerOpenWithStopAndFilterStringTs($tableName, $startRow, $stopRow, $filterString, $timestamp)
  {
    $args = new Hbase_scannerOpenWithStopAndFilterStringTs_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->filterString = $filterString;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithStopAndFilterStringTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithStopAndFilterStringTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithStopAndFilterStringTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithStopAndFilterStringTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithStopAndFilterStringTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithStopAndFilterStringTs failed: unknown result");
  }

  public function scannerOpenWithIndexAndColumns($tableName, $columns, $expr)
  {
    $this->send_scannerOpenWithIndexAndColumns($tableName, $columns, $expr);
    return $this->recv_scannerOpenWithIndexAndColumns();
  }

  public function send_scannerOpenWithIndexAndColumns($tableName, $columns, $expr)
  {
    $args = new Hbase_scannerOpenWithIndexAndColumns_args();
    $args->tableName = $tableName;
    $args->columns = $columns;
    $args->expr = $expr;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithIndexAndColumns', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithIndexAndColumns', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithIndexAndColumns()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithIndexAndColumns_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithIndexAndColumns_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithIndexAndColumns failed: unknown result");
  }

  public function scannerOpenWithIndexExpression($tableName, $columns, $expr)
  {
    $this->send_scannerOpenWithIndexExpression($tableName, $columns, $expr);
    return $this->recv_scannerOpenWithIndexExpression();
  }

  public function send_scannerOpenWithIndexExpression($tableName, $columns, $expr)
  {
    $args = new Hbase_scannerOpenWithIndexExpression_args();
    $args->tableName = $tableName;
    $args->columns = $columns;
    $args->expr = $expr;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithIndexExpression', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithIndexExpression', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithIndexExpression()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithIndexExpression_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithIndexExpression_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithIndexExpression failed: unknown result");
  }

  public function scannerOpenWithIndexExpressionTs($tableName, $columns, $expr, $timestamp)
  {
    $this->send_scannerOpenWithIndexExpressionTs($tableName, $columns, $expr, $timestamp);
    return $this->recv_scannerOpenWithIndexExpressionTs();
  }

  public function send_scannerOpenWithIndexExpressionTs($tableName, $columns, $expr, $timestamp)
  {
    $args = new Hbase_scannerOpenWithIndexExpressionTs_args();
    $args->tableName = $tableName;
    $args->columns = $columns;
    $args->expr = $expr;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithIndexExpressionTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithIndexExpressionTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithIndexExpressionTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithIndexExpressionTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithIndexExpressionTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithIndexExpressionTs failed: unknown result");
  }

  public function scannerOpenWithStopAndIndexExpression($tableName, $startRow, $stopRow, $columns, $expr)
  {
    $this->send_scannerOpenWithStopAndIndexExpression($tableName, $startRow, $stopRow, $columns, $expr);
    return $this->recv_scannerOpenWithStopAndIndexExpression();
  }

  public function send_scannerOpenWithStopAndIndexExpression($tableName, $startRow, $stopRow, $columns, $expr)
  {
    $args = new Hbase_scannerOpenWithStopAndIndexExpression_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->expr = $expr;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithStopAndIndexExpression', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithStopAndIndexExpression', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithStopAndIndexExpression()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithStopAndIndexExpression_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithStopAndIndexExpression_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithStopAndIndexExpression failed: unknown result");
  }

  public function scannerOpenWithStopAndIndexExpressionTs($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs)
  {
    $this->send_scannerOpenWithStopAndIndexExpressionTs($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs);
    return $this->recv_scannerOpenWithStopAndIndexExpressionTs();
  }

  public function send_scannerOpenWithStopAndIndexExpressionTs($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs)
  {
    $args = new Hbase_scannerOpenWithStopAndIndexExpressionTs_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->expr = $expr;
    $args->minTs = $minTs;
    $args->maxTs = $maxTs;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerOpenWithStopAndIndexExpressionTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerOpenWithStopAndIndexExpressionTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerOpenWithStopAndIndexExpressionTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerOpenWithStopAndIndexExpressionTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerOpenWithStopAndIndexExpressionTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("scannerOpenWithStopAndIndexExpressionTs failed: unknown result");
  }

  public function aggTopN($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs, $topnColumns, $topnN, $topnMaxN, $isDesc)
  {
    $this->send_aggTopN($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs, $topnColumns, $topnN, $topnMaxN, $isDesc);
    return $this->recv_aggTopN();
  }

  public function send_aggTopN($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs, $topnColumns, $topnN, $topnMaxN, $isDesc)
  {
    $args = new Hbase_aggTopN_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->expr = $expr;
    $args->minTs = $minTs;
    $args->maxTs = $maxTs;
    $args->topnColumns = $topnColumns;
    $args->topnN = $topnN;
    $args->topnMaxN = $topnMaxN;
    $args->isDesc = $isDesc;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'aggTopN', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('aggTopN', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_aggTopN()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_aggTopN_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_aggTopN_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("aggTopN failed: unknown result");
  }

  public function aggRowNum($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs)
  {
    $this->send_aggRowNum($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs);
    return $this->recv_aggRowNum();
  }

  public function send_aggRowNum($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs)
  {
    $args = new Hbase_aggRowNum_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->expr = $expr;
    $args->minTs = $minTs;
    $args->maxTs = $maxTs;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'aggRowNum', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('aggRowNum', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_aggRowNum()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_aggRowNum_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_aggRowNum_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("aggRowNum failed: unknown result");
  }

  public function aggFacetingByTimestamp($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs, $startTs, $endTs, $intervalTs)
  {
    $this->send_aggFacetingByTimestamp($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs, $startTs, $endTs, $intervalTs);
    return $this->recv_aggFacetingByTimestamp();
  }

  public function send_aggFacetingByTimestamp($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs, $startTs, $endTs, $intervalTs)
  {
    $args = new Hbase_aggFacetingByTimestamp_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->expr = $expr;
    $args->minTs = $minTs;
    $args->maxTs = $maxTs;
    $args->startTs = $startTs;
    $args->endTs = $endTs;
    $args->intervalTs = $intervalTs;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'aggFacetingByTimestamp', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('aggFacetingByTimestamp', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_aggFacetingByTimestamp()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_aggFacetingByTimestamp_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_aggFacetingByTimestamp_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("aggFacetingByTimestamp failed: unknown result");
  }

  public function getTableIndexDesc($tableName)
  {
    $this->send_getTableIndexDesc($tableName);
    return $this->recv_getTableIndexDesc();
  }

  public function send_getTableIndexDesc($tableName)
  {
    $args = new Hbase_getTableIndexDesc_args();
    $args->tableName = $tableName;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getTableIndexDesc', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getTableIndexDesc', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getTableIndexDesc()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getTableIndexDesc_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getTableIndexDesc_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getTableIndexDesc failed: unknown result");
  }

  public function miniScanWithScan($tableName, $scan)
  {
    $this->send_miniScanWithScan($tableName, $scan);
    return $this->recv_miniScanWithScan();
  }

  public function send_miniScanWithScan($tableName, $scan)
  {
    $args = new Hbase_miniScanWithScan_args();
    $args->tableName = $tableName;
    $args->scan = $scan;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'miniScanWithScan', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('miniScanWithScan', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_miniScanWithScan()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_miniScanWithScan_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_miniScanWithScan_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("miniScanWithScan failed: unknown result");
  }

  public function miniScanWithStop($tableName, $startRow, $stopRow, $columns)
  {
    $this->send_miniScanWithStop($tableName, $startRow, $stopRow, $columns);
    return $this->recv_miniScanWithStop();
  }

  public function send_miniScanWithStop($tableName, $startRow, $stopRow, $columns)
  {
    $args = new Hbase_miniScanWithStop_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'miniScanWithStop', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('miniScanWithStop', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_miniScanWithStop()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_miniScanWithStop_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_miniScanWithStop_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("miniScanWithStop failed: unknown result");
  }

  public function miniScanWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp)
  {
    $this->send_miniScanWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp);
    return $this->recv_miniScanWithStopTs();
  }

  public function send_miniScanWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp)
  {
    $args = new Hbase_miniScanWithStopTs_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'miniScanWithStopTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('miniScanWithStopTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_miniScanWithStopTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_miniScanWithStopTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_miniScanWithStopTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("miniScanWithStopTs failed: unknown result");
  }

  public function miniScanWithIndexExpression($tableName, $columns, $expr)
  {
    $this->send_miniScanWithIndexExpression($tableName, $columns, $expr);
    return $this->recv_miniScanWithIndexExpression();
  }

  public function send_miniScanWithIndexExpression($tableName, $columns, $expr)
  {
    $args = new Hbase_miniScanWithIndexExpression_args();
    $args->tableName = $tableName;
    $args->columns = $columns;
    $args->expr = $expr;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'miniScanWithIndexExpression', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('miniScanWithIndexExpression', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_miniScanWithIndexExpression()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_miniScanWithIndexExpression_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_miniScanWithIndexExpression_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("miniScanWithIndexExpression failed: unknown result");
  }

  public function miniScanWithStopAndIndexExpression($tableName, $startRow, $stopRow, $columns, $expr)
  {
    $this->send_miniScanWithStopAndIndexExpression($tableName, $startRow, $stopRow, $columns, $expr);
    return $this->recv_miniScanWithStopAndIndexExpression();
  }

  public function send_miniScanWithStopAndIndexExpression($tableName, $startRow, $stopRow, $columns, $expr)
  {
    $args = new Hbase_miniScanWithStopAndIndexExpression_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->expr = $expr;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'miniScanWithStopAndIndexExpression', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('miniScanWithStopAndIndexExpression', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_miniScanWithStopAndIndexExpression()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_miniScanWithStopAndIndexExpression_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_miniScanWithStopAndIndexExpression_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("miniScanWithStopAndIndexExpression failed: unknown result");
  }

  public function miniScanWithIndexExpressionTs($tableName, $columns, $expr, $timestamp)
  {
    $this->send_miniScanWithIndexExpressionTs($tableName, $columns, $expr, $timestamp);
    return $this->recv_miniScanWithIndexExpressionTs();
  }

  public function send_miniScanWithIndexExpressionTs($tableName, $columns, $expr, $timestamp)
  {
    $args = new Hbase_miniScanWithIndexExpressionTs_args();
    $args->tableName = $tableName;
    $args->columns = $columns;
    $args->expr = $expr;
    $args->timestamp = $timestamp;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'miniScanWithIndexExpressionTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('miniScanWithIndexExpressionTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_miniScanWithIndexExpressionTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_miniScanWithIndexExpressionTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_miniScanWithIndexExpressionTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("miniScanWithIndexExpressionTs failed: unknown result");
  }

  public function miniScanWithStopAndIndexExpressionTs($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs)
  {
    $this->send_miniScanWithStopAndIndexExpressionTs($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs);
    return $this->recv_miniScanWithStopAndIndexExpressionTs();
  }

  public function send_miniScanWithStopAndIndexExpressionTs($tableName, $startRow, $stopRow, $columns, $expr, $minTs, $maxTs)
  {
    $args = new Hbase_miniScanWithStopAndIndexExpressionTs_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->expr = $expr;
    $args->minTs = $minTs;
    $args->maxTs = $maxTs;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'miniScanWithStopAndIndexExpressionTs', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('miniScanWithStopAndIndexExpressionTs', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_miniScanWithStopAndIndexExpressionTs()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_miniScanWithStopAndIndexExpressionTs_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_miniScanWithStopAndIndexExpressionTs_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("miniScanWithStopAndIndexExpressionTs failed: unknown result");
  }

  public function searchMaxScoreResult($tableName, $startRow, $stopRow, $columns, $expr, $count, $minTs, $maxTs)
  {
    $this->send_searchMaxScoreResult($tableName, $startRow, $stopRow, $columns, $expr, $count, $minTs, $maxTs);
    return $this->recv_searchMaxScoreResult();
  }

  public function send_searchMaxScoreResult($tableName, $startRow, $stopRow, $columns, $expr, $count, $minTs, $maxTs)
  {
    $args = new Hbase_searchMaxScoreResult_args();
    $args->tableName = $tableName;
    $args->startRow = $startRow;
    $args->stopRow = $stopRow;
    $args->columns = $columns;
    $args->expr = $expr;
    $args->count = $count;
    $args->minTs = $minTs;
    $args->maxTs = $maxTs;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'searchMaxScoreResult', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('searchMaxScoreResult', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_searchMaxScoreResult()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_searchMaxScoreResult_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_searchMaxScoreResult_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("searchMaxScoreResult failed: unknown result");
  }

  public function scannerGet($id)
  {
    $this->send_scannerGet($id);
    return $this->recv_scannerGet();
  }

  public function send_scannerGet($id)
  {
    $args = new Hbase_scannerGet_args();
    $args->id = $id;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerGet', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerGet', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerGet()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerGet_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerGet_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new Exception("scannerGet failed: unknown result");
  }

  public function scannerGetList($id, $nbRows)
  {
    $this->send_scannerGetList($id, $nbRows);
    return $this->recv_scannerGetList();
  }

  public function send_scannerGetList($id, $nbRows)
  {
    $args = new Hbase_scannerGetList_args();
    $args->id = $id;
    $args->nbRows = $nbRows;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerGetList', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerGetList', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerGetList()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerGetList_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerGetList_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new Exception("scannerGetList failed: unknown result");
  }

  public function scannerGetListByJson($id, $nbRows)
  {
    $this->send_scannerGetListByJson($id, $nbRows);
    return $this->recv_scannerGetListByJson();
  }

  public function send_scannerGetListByJson($id, $nbRows)
  {
    $args = new Hbase_scannerGetListByJson_args();
    $args->id = $id;
    $args->nbRows = $nbRows;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerGetListByJson', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerGetListByJson', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerGetListByJson()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerGetListByJson_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerGetListByJson_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    throw new Exception("scannerGetListByJson failed: unknown result");
  }

  public function scannerClose($id)
  {
    $this->send_scannerClose($id);
    $this->recv_scannerClose();
  }

  public function send_scannerClose($id)
  {
    $args = new Hbase_scannerClose_args();
    $args->id = $id;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'scannerClose', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('scannerClose', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_scannerClose()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_scannerClose_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_scannerClose_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    if ($result->ia !== null) {
      throw $result->ia;
    }
    return;
  }

  public function getRegionInfo($row)
  {
    $this->send_getRegionInfo($row);
    return $this->recv_getRegionInfo();
  }

  public function send_getRegionInfo($row)
  {
    $args = new Hbase_getRegionInfo_args();
    $args->row = $row;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'getRegionInfo', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('getRegionInfo', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_getRegionInfo()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_getRegionInfo_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_getRegionInfo_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->io !== null) {
      throw $result->io;
    }
    throw new Exception("getRegionInfo failed: unknown result");
  }

  public function QstoreBatchRead($columnstore_list)
  {
    $this->send_QstoreBatchRead($columnstore_list);
    return $this->recv_QstoreBatchRead();
  }

  public function send_QstoreBatchRead($columnstore_list)
  {
    $args = new Hbase_QstoreBatchRead_args();
    $args->columnstore_list = $columnstore_list;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'QstoreBatchRead', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('QstoreBatchRead', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_QstoreBatchRead()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_QstoreBatchRead_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_QstoreBatchRead_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("QstoreBatchRead failed: unknown result");
  }

  public function QstoreBatchReadDigest($columnstore_list)
  {
    $this->send_QstoreBatchReadDigest($columnstore_list);
    return $this->recv_QstoreBatchReadDigest();
  }

  public function send_QstoreBatchReadDigest($columnstore_list)
  {
    $args = new Hbase_QstoreBatchReadDigest_args();
    $args->columnstore_list = $columnstore_list;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'QstoreBatchReadDigest', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('QstoreBatchReadDigest', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_QstoreBatchReadDigest()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_QstoreBatchReadDigest_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_QstoreBatchReadDigest_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("QstoreBatchReadDigest failed: unknown result");
  }

  public function QstoreBatchWrite($columnstore_list)
  {
    $this->send_QstoreBatchWrite($columnstore_list);
    $this->recv_QstoreBatchWrite();
  }

  public function send_QstoreBatchWrite($columnstore_list)
  {
    $args = new Hbase_QstoreBatchWrite_args();
    $args->columnstore_list = $columnstore_list;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'QstoreBatchWrite', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('QstoreBatchWrite', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_QstoreBatchWrite()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_QstoreBatchWrite_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_QstoreBatchWrite_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    return;
  }

  public function QstoreMultiRead($keystore_list, $consistency_level)
  {
    $this->send_QstoreMultiRead($keystore_list, $consistency_level);
    return $this->recv_QstoreMultiRead();
  }

  public function send_QstoreMultiRead($keystore_list, $consistency_level)
  {
    $args = new Hbase_QstoreMultiRead_args();
    $args->keystore_list = $keystore_list;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'QstoreMultiRead', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('QstoreMultiRead', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_QstoreMultiRead()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_QstoreMultiRead_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_QstoreMultiRead_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("QstoreMultiRead failed: unknown result");
  }

  public function QstoreMultiReadDigest($keystore_list, $consistency_level)
  {
    $this->send_QstoreMultiReadDigest($keystore_list, $consistency_level);
    return $this->recv_QstoreMultiReadDigest();
  }

  public function send_QstoreMultiReadDigest($keystore_list, $consistency_level)
  {
    $args = new Hbase_QstoreMultiReadDigest_args();
    $args->keystore_list = $keystore_list;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'QstoreMultiReadDigest', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('QstoreMultiReadDigest', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_QstoreMultiReadDigest()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_QstoreMultiReadDigest_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_QstoreMultiReadDigest_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("QstoreMultiReadDigest failed: unknown result");
  }

  public function QstoreMultiWrite($keystore_list, $consistency_level)
  {
    $this->send_QstoreMultiWrite($keystore_list, $consistency_level);
    $this->recv_QstoreMultiWrite();
  }

  public function send_QstoreMultiWrite($keystore_list, $consistency_level)
  {
    $args = new Hbase_QstoreMultiWrite_args();
    $args->keystore_list = $keystore_list;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'QstoreMultiWrite', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('QstoreMultiWrite', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_QstoreMultiWrite()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_QstoreMultiWrite_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_QstoreMultiWrite_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    return;
  }

  public function QstoreMultiDelete($keystore_list, $consistency_level)
  {
    $this->send_QstoreMultiDelete($keystore_list, $consistency_level);
    $this->recv_QstoreMultiDelete();
  }

  public function send_QstoreMultiDelete($keystore_list, $consistency_level)
  {
    $args = new Hbase_QstoreMultiDelete_args();
    $args->keystore_list = $keystore_list;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'QstoreMultiDelete', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('QstoreMultiDelete', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_QstoreMultiDelete()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_QstoreMultiDelete_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_QstoreMultiDelete_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    return;
  }

  public function InnerMultiRead($keystore_list, $consistency_level)
  {
    $this->send_InnerMultiRead($keystore_list, $consistency_level);
    return $this->recv_InnerMultiRead();
  }

  public function send_InnerMultiRead($keystore_list, $consistency_level)
  {
    $args = new Hbase_InnerMultiRead_args();
    $args->keystore_list = $keystore_list;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'InnerMultiRead', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('InnerMultiRead', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_InnerMultiRead()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_InnerMultiRead_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_InnerMultiRead_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("InnerMultiRead failed: unknown result");
  }

  public function InnerMultiReadDigest($keystore_list, $consistency_level)
  {
    $this->send_InnerMultiReadDigest($keystore_list, $consistency_level);
    return $this->recv_InnerMultiReadDigest();
  }

  public function send_InnerMultiReadDigest($keystore_list, $consistency_level)
  {
    $args = new Hbase_InnerMultiReadDigest_args();
    $args->keystore_list = $keystore_list;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'InnerMultiReadDigest', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('InnerMultiReadDigest', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_InnerMultiReadDigest()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_InnerMultiReadDigest_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_InnerMultiReadDigest_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->success !== null) {
      return $result->success;
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    throw new Exception("InnerMultiReadDigest failed: unknown result");
  }

  public function InnerMultiWrite($keystore_list, $consistency_level)
  {
    $this->send_InnerMultiWrite($keystore_list, $consistency_level);
    $this->recv_InnerMultiWrite();
  }

  public function send_InnerMultiWrite($keystore_list, $consistency_level)
  {
    $args = new Hbase_InnerMultiWrite_args();
    $args->keystore_list = $keystore_list;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'InnerMultiWrite', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('InnerMultiWrite', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_InnerMultiWrite()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_InnerMultiWrite_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_InnerMultiWrite_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    return;
  }

  public function TransferMultiWrite($keystore_list, $consistency_level)
  {
    $this->send_TransferMultiWrite($keystore_list, $consistency_level);
    $this->recv_TransferMultiWrite();
  }

  public function send_TransferMultiWrite($keystore_list, $consistency_level)
  {
    $args = new Hbase_TransferMultiWrite_args();
    $args->keystore_list = $keystore_list;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'TransferMultiWrite', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('TransferMultiWrite', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_TransferMultiWrite()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_TransferMultiWrite_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_TransferMultiWrite_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    return;
  }

  public function InnerMultiDelete($keystore_list, $consistency_level)
  {
    $this->send_InnerMultiDelete($keystore_list, $consistency_level);
    $this->recv_InnerMultiDelete();
  }

  public function send_InnerMultiDelete($keystore_list, $consistency_level)
  {
    $args = new Hbase_InnerMultiDelete_args();
    $args->keystore_list = $keystore_list;
    $args->consistency_level = $consistency_level;
    $bin_accel = ($this->output_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_write_binary');
    if ($bin_accel)
    {
      thrift_protocol_write_binary($this->output_, 'InnerMultiDelete', TMessageType::CALL, $args, $this->seqid_, $this->output_->isStrictWrite());
    }
    else
    {
      $this->output_->writeMessageBegin('InnerMultiDelete', TMessageType::CALL, $this->seqid_);
      $args->write($this->output_);
      $this->output_->writeMessageEnd();
      $this->output_->getTransport()->flush();
    }
  }

  public function recv_InnerMultiDelete()
  {
    $bin_accel = ($this->input_ instanceof TProtocol::$TBINARYPROTOCOLACCELERATED) && function_exists('thrift_protocol_read_binary');
    if ($bin_accel) $result = thrift_protocol_read_binary($this->input_, 'Hbase_InnerMultiDelete_result', $this->input_->isStrictRead());
    else
    {
      $rseqid = 0;
      $fname = null;
      $mtype = 0;

      $this->input_->readMessageBegin($fname, $mtype, $rseqid);
      if ($mtype == TMessageType::EXCEPTION) {
        $x = new TApplicationException();
        $x->read($this->input_);
        $this->input_->readMessageEnd();
        throw $x;
      }
      $result = new Hbase_InnerMultiDelete_result();
      $result->read($this->input_);
      $this->input_->readMessageEnd();
    }
    if ($result->qe !== null) {
      throw $result->qe;
    }
    return;
  }

}

// HELPER FUNCTIONS AND STRUCTURES

class Hbase_enableTable_args {
  static $_TSPEC;

  public $tableName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_enableTable_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_enableTable_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_enableTable_result {
  static $_TSPEC;

  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_enableTable_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_enableTable_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_disableTable_args {
  static $_TSPEC;

  public $tableName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_disableTable_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_disableTable_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_disableTable_result {
  static $_TSPEC;

  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_disableTable_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_disableTable_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_isTableEnabled_args {
  static $_TSPEC;

  public $tableName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_isTableEnabled_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_isTableEnabled_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_isTableEnabled_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_isTableEnabled_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_isTableEnabled_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_compact_args {
  static $_TSPEC;

  public $tableNameOrRegionName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableNameOrRegionName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableNameOrRegionName'])) {
        $this->tableNameOrRegionName = $vals['tableNameOrRegionName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_compact_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableNameOrRegionName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_compact_args');
    if ($this->tableNameOrRegionName !== null) {
      $xfer += $output->writeFieldBegin('tableNameOrRegionName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableNameOrRegionName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_compact_result {
  static $_TSPEC;

  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_compact_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_compact_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_majorCompact_args {
  static $_TSPEC;

  public $tableNameOrRegionName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableNameOrRegionName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableNameOrRegionName'])) {
        $this->tableNameOrRegionName = $vals['tableNameOrRegionName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_majorCompact_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableNameOrRegionName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_majorCompact_args');
    if ($this->tableNameOrRegionName !== null) {
      $xfer += $output->writeFieldBegin('tableNameOrRegionName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableNameOrRegionName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_majorCompact_result {
  static $_TSPEC;

  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_majorCompact_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_majorCompact_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getTableNames_args {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'Hbase_getTableNames_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableNames_args');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getTableNames_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getTableNames_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size30 = 0;
            $_etype33 = 0;
            $xfer += $input->readListBegin($_etype33, $_size30);
            for ($_i34 = 0; $_i34 < $_size30; ++$_i34)
            {
              $elem35 = null;
              $xfer += $input->readString($elem35);
              $this->success []= $elem35;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableNames_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRING, count($this->success));
        {
          foreach ($this->success as $iter36)
          {
            $xfer += $output->writeString($iter36);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getColumnDescriptors_args {
  static $_TSPEC;

  public $tableName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getColumnDescriptors_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getColumnDescriptors_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnDescriptor',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getColumnDescriptors_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size37 = 0;
            $_ktype38 = 0;
            $_vtype39 = 0;
            $xfer += $input->readMapBegin($_ktype38, $_vtype39, $_size37);
            for ($_i41 = 0; $_i41 < $_size37; ++$_i41)
            {
              $key42 = '';
              $val43 = new ColumnDescriptor();
              $xfer += $input->readString($key42);
              $val43 = new ColumnDescriptor();
              $xfer += $val43->read($input);
              $this->success[$key42] = $val43;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $kiter44 => $viter45)
          {
            $xfer += $output->writeString($kiter44);
            $xfer += $viter45->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getTableRegions_args {
  static $_TSPEC;

  public $tableName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getTableRegions_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableRegions_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getTableRegions_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRegionInfo',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getTableRegions_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size46 = 0;
            $_etype49 = 0;
            $xfer += $input->readListBegin($_etype49, $_size46);
            for ($_i50 = 0; $_i50 < $_size46; ++$_i50)
            {
              $elem51 = null;
              $elem51 = new TRegionInfo();
              $xfer += $elem51->read($input);
              $this->success []= $elem51;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableRegions_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter52)
          {
            $xfer += $iter52->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_createTable_args {
  static $_TSPEC;

  public $tableName = null;
  public $columnFamilies = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columnFamilies',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnDescriptor',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['columnFamilies'])) {
        $this->columnFamilies = $vals['columnFamilies'];
      }
    }
  }

  public function getName() {
    return 'Hbase_createTable_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columnFamilies = array();
            $_size53 = 0;
            $_etype56 = 0;
            $xfer += $input->readListBegin($_etype56, $_size53);
            for ($_i57 = 0; $_i57 < $_size53; ++$_i57)
            {
              $elem58 = null;
              $elem58 = new ColumnDescriptor();
              $xfer += $elem58->read($input);
              $this->columnFamilies []= $elem58;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_createTable_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columnFamilies !== null) {
      if (!is_array($this->columnFamilies)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columnFamilies', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columnFamilies));
        {
          foreach ($this->columnFamilies as $iter59)
          {
            $xfer += $iter59->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_createTable_result {
  static $_TSPEC;

  public $io = null;
  public $ia = null;
  public $exist = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        3 => array(
          'var' => 'exist',
          'type' => TType::STRUCT,
          'class' => 'AlreadyExists',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
      if (isset($vals['exist'])) {
        $this->exist = $vals['exist'];
      }
    }
  }

  public function getName() {
    return 'Hbase_createTable_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->exist = new AlreadyExists();
            $xfer += $this->exist->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_createTable_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->exist !== null) {
      $xfer += $output->writeFieldBegin('exist', TType::STRUCT, 3);
      $xfer += $this->exist->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_createTableForYuntu_args {
  static $_TSPEC;

  public $clusterInfo = null;
  public $tableName = null;
  public $colDesc = null;
  public $userName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'clusterInfo',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'colDesc',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'userName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['clusterInfo'])) {
        $this->clusterInfo = $vals['clusterInfo'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['colDesc'])) {
        $this->colDesc = $vals['colDesc'];
      }
      if (isset($vals['userName'])) {
        $this->userName = $vals['userName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_createTableForYuntu_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->clusterInfo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->colDesc);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->userName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_createTableForYuntu_args');
    if ($this->clusterInfo !== null) {
      $xfer += $output->writeFieldBegin('clusterInfo', TType::STRING, 1);
      $xfer += $output->writeString($this->clusterInfo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->colDesc !== null) {
      $xfer += $output->writeFieldBegin('colDesc', TType::STRING, 3);
      $xfer += $output->writeString($this->colDesc);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userName !== null) {
      $xfer += $output->writeFieldBegin('userName', TType::STRING, 4);
      $xfer += $output->writeString($this->userName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_createTableForYuntu_result {
  static $_TSPEC;

  public $io = null;
  public $ia = null;
  public $exist = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        3 => array(
          'var' => 'exist',
          'type' => TType::STRUCT,
          'class' => 'AlreadyExists',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
      if (isset($vals['exist'])) {
        $this->exist = $vals['exist'];
      }
    }
  }

  public function getName() {
    return 'Hbase_createTableForYuntu_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->exist = new AlreadyExists();
            $xfer += $this->exist->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_createTableForYuntu_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->exist !== null) {
      $xfer += $output->writeFieldBegin('exist', TType::STRUCT, 3);
      $xfer += $this->exist->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteTable_args {
  static $_TSPEC;

  public $tableName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteTable_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteTable_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteTable_result {
  static $_TSPEC;

  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteTable_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteTable_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteTableForYuntu_args {
  static $_TSPEC;

  public $clusterInfo = null;
  public $tableName = null;
  public $userName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'clusterInfo',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'userName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['clusterInfo'])) {
        $this->clusterInfo = $vals['clusterInfo'];
      }
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['userName'])) {
        $this->userName = $vals['userName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteTableForYuntu_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->clusterInfo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->userName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteTableForYuntu_args');
    if ($this->clusterInfo !== null) {
      $xfer += $output->writeFieldBegin('clusterInfo', TType::STRING, 1);
      $xfer += $output->writeString($this->clusterInfo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 2);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userName !== null) {
      $xfer += $output->writeFieldBegin('userName', TType::STRING, 3);
      $xfer += $output->writeString($this->userName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteTableForYuntu_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I64,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteTableForYuntu_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteTableForYuntu_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I64, 0);
      $xfer += $output->writeI64($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_isDeleteTableDoneForYuntu_args {
  static $_TSPEC;

  public $id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
    }
  }

  public function getName() {
    return 'Hbase_isDeleteTableDoneForYuntu_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_isDeleteTableDoneForYuntu_args');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I64, 1);
      $xfer += $output->writeI64($this->id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_isDeleteTableDoneForYuntu_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_isDeleteTableDoneForYuntu_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_isDeleteTableDoneForYuntu_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_get_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $column = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
    }
  }

  public function getName() {
    return 'Hbase_get_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_get_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column !== null) {
      $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
      $xfer += $output->writeString($this->column);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_get_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TCell',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_get_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size60 = 0;
            $_etype63 = 0;
            $xfer += $input->readListBegin($_etype63, $_size60);
            for ($_i64 = 0; $_i64 < $_size60; ++$_i64)
            {
              $elem65 = null;
              $elem65 = new TCell();
              $xfer += $elem65->read($input);
              $this->success []= $elem65;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_get_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter66)
          {
            $xfer += $iter66->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getVer_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $column = null;
  public $numVersions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'numVersions',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
      if (isset($vals['numVersions'])) {
        $this->numVersions = $vals['numVersions'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getVer_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->numVersions);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getVer_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column !== null) {
      $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
      $xfer += $output->writeString($this->column);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numVersions !== null) {
      $xfer += $output->writeFieldBegin('numVersions', TType::I32, 4);
      $xfer += $output->writeI32($this->numVersions);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getVer_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TCell',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getVer_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size67 = 0;
            $_etype70 = 0;
            $xfer += $input->readListBegin($_etype70, $_size67);
            for ($_i71 = 0; $_i71 < $_size67; ++$_i71)
            {
              $elem72 = null;
              $elem72 = new TCell();
              $xfer += $elem72->read($input);
              $this->success []= $elem72;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getVer_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter73)
          {
            $xfer += $iter73->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getVerTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $column = null;
  public $timestamp = null;
  public $numVersions = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'numVersions',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['numVersions'])) {
        $this->numVersions = $vals['numVersions'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getVerTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->numVersions);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getVerTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column !== null) {
      $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
      $xfer += $output->writeString($this->column);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numVersions !== null) {
      $xfer += $output->writeFieldBegin('numVersions', TType::I32, 5);
      $xfer += $output->writeI32($this->numVersions);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getVerTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TCell',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getVerTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size74 = 0;
            $_etype77 = 0;
            $xfer += $input->readListBegin($_etype77, $_size74);
            for ($_i78 = 0; $_i78 < $_size74; ++$_i78)
            {
              $elem79 = null;
              $elem79 = new TCell();
              $xfer += $elem79->read($input);
              $this->success []= $elem79;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getVerTs_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter80)
          {
            $xfer += $iter80->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRow_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRow_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRow_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRow_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRow_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size81 = 0;
            $_etype84 = 0;
            $xfer += $input->readListBegin($_etype84, $_size81);
            for ($_i85 = 0; $_i85 < $_size81; ++$_i85)
            {
              $elem86 = null;
              $elem86 = new TRowResult();
              $xfer += $elem86->read($input);
              $this->success []= $elem86;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRow_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter87)
          {
            $xfer += $iter87->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumns_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumns_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size88 = 0;
            $_etype91 = 0;
            $xfer += $input->readListBegin($_etype91, $_size88);
            for ($_i92 = 0; $_i92 < $_size88; ++$_i92)
            {
              $elem93 = null;
              $xfer += $input->readString($elem93);
              $this->columns []= $elem93;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter94)
          {
            $xfer += $output->writeString($iter94);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumns_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumns_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size95 = 0;
            $_etype98 = 0;
            $xfer += $input->readListBegin($_etype98, $_size95);
            for ($_i99 = 0; $_i99 < $_size95; ++$_i99)
            {
              $elem100 = null;
              $elem100 = new TRowResult();
              $xfer += $elem100->read($input);
              $this->success []= $elem100;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter101)
          {
            $xfer += $iter101->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size102 = 0;
            $_etype105 = 0;
            $xfer += $input->readListBegin($_etype105, $_size102);
            for ($_i106 = 0; $_i106 < $_size102; ++$_i106)
            {
              $elem107 = null;
              $elem107 = new TRowResult();
              $xfer += $elem107->read($input);
              $this->success []= $elem107;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowTs_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter108)
          {
            $xfer += $iter108->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumnsTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $columns = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnsTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size109 = 0;
            $_etype112 = 0;
            $xfer += $input->readListBegin($_etype112, $_size109);
            for ($_i113 = 0; $_i113 < $_size109; ++$_i113)
            {
              $elem114 = null;
              $xfer += $input->readString($elem114);
              $this->columns []= $elem114;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter115)
          {
            $xfer += $output->writeString($iter115);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumnsTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnsTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size116 = 0;
            $_etype119 = 0;
            $xfer += $input->readListBegin($_etype119, $_size116);
            for ($_i120 = 0; $_i120 < $_size116; ++$_i120)
            {
              $elem121 = null;
              $elem121 = new TRowResult();
              $xfer += $elem121->read($input);
              $this->success []= $elem121;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter122)
          {
            $xfer += $iter122->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumnsTsRange_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $columns = null;
  public $minTs = null;
  public $maxTs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'minTs',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'maxTs',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['minTs'])) {
        $this->minTs = $vals['minTs'];
      }
      if (isset($vals['maxTs'])) {
        $this->maxTs = $vals['maxTs'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnsTsRange_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size123 = 0;
            $_etype126 = 0;
            $xfer += $input->readListBegin($_etype126, $_size123);
            for ($_i127 = 0; $_i127 < $_size123; ++$_i127)
            {
              $elem128 = null;
              $xfer += $input->readString($elem128);
              $this->columns []= $elem128;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTsRange_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter129)
          {
            $xfer += $output->writeString($iter129);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minTs !== null) {
      $xfer += $output->writeFieldBegin('minTs', TType::I64, 4);
      $xfer += $output->writeI64($this->minTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxTs !== null) {
      $xfer += $output->writeFieldBegin('maxTs', TType::I64, 5);
      $xfer += $output->writeI64($this->maxTs);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumnsTsRange_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnsTsRange_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size130 = 0;
            $_etype133 = 0;
            $xfer += $input->readListBegin($_etype133, $_size130);
            for ($_i134 = 0; $_i134 < $_size130; ++$_i134)
            {
              $elem135 = null;
              $elem135 = new TRowResult();
              $xfer += $elem135->read($input);
              $this->success []= $elem135;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTsRange_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter136)
          {
            $xfer += $iter136->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumnPrefix_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $prefix = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'prefix',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['prefix'])) {
        $this->prefix = $vals['prefix'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnPrefix_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->prefix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnPrefix_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->prefix !== null) {
      $xfer += $output->writeFieldBegin('prefix', TType::STRING, 3);
      $xfer += $output->writeString($this->prefix);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumnPrefix_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnPrefix_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size137 = 0;
            $_etype140 = 0;
            $xfer += $input->readListBegin($_etype140, $_size137);
            for ($_i141 = 0; $_i141 < $_size137; ++$_i141)
            {
              $elem142 = null;
              $elem142 = new TRowResult();
              $xfer += $elem142->read($input);
              $this->success []= $elem142;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnPrefix_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter143)
          {
            $xfer += $iter143->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumnPrefixTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $prefix = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'prefix',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['prefix'])) {
        $this->prefix = $vals['prefix'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnPrefixTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->prefix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnPrefixTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->prefix !== null) {
      $xfer += $output->writeFieldBegin('prefix', TType::STRING, 3);
      $xfer += $output->writeString($this->prefix);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowWithColumnPrefixTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowWithColumnPrefixTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size144 = 0;
            $_etype147 = 0;
            $xfer += $input->readListBegin($_etype147, $_size144);
            for ($_i148 = 0; $_i148 < $_size144; ++$_i148)
            {
              $elem149 = null;
              $elem149 = new TRowResult();
              $xfer += $elem149->read($input);
              $this->success []= $elem149;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowWithColumnPrefixTs_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter150)
          {
            $xfer += $iter150->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRows_args {
  static $_TSPEC;

  public $tableName = null;
  public $rows = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'rows',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['rows'])) {
        $this->rows = $vals['rows'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRows_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->rows = array();
            $_size151 = 0;
            $_etype154 = 0;
            $xfer += $input->readListBegin($_etype154, $_size151);
            for ($_i155 = 0; $_i155 < $_size151; ++$_i155)
            {
              $elem156 = null;
              $xfer += $input->readString($elem156);
              $this->rows []= $elem156;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRows_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rows !== null) {
      if (!is_array($this->rows)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rows', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->rows));
        {
          foreach ($this->rows as $iter157)
          {
            $xfer += $output->writeString($iter157);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRows_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRows_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size158 = 0;
            $_etype161 = 0;
            $xfer += $input->readListBegin($_etype161, $_size158);
            for ($_i162 = 0; $_i162 < $_size158; ++$_i162)
            {
              $elem163 = null;
              $elem163 = new TRowResult();
              $xfer += $elem163->read($input);
              $this->success []= $elem163;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRows_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter164)
          {
            $xfer += $iter164->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowsTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $rows = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'rows',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['rows'])) {
        $this->rows = $vals['rows'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowsTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->rows = array();
            $_size165 = 0;
            $_etype168 = 0;
            $xfer += $input->readListBegin($_etype168, $_size165);
            for ($_i169 = 0; $_i169 < $_size165; ++$_i169)
            {
              $elem170 = null;
              $xfer += $input->readString($elem170);
              $this->rows []= $elem170;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rows !== null) {
      if (!is_array($this->rows)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rows', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->rows));
        {
          foreach ($this->rows as $iter171)
          {
            $xfer += $output->writeString($iter171);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowsTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowsTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size172 = 0;
            $_etype175 = 0;
            $xfer += $input->readListBegin($_etype175, $_size172);
            for ($_i176 = 0; $_i176 < $_size172; ++$_i176)
            {
              $elem177 = null;
              $elem177 = new TRowResult();
              $xfer += $elem177->read($input);
              $this->success []= $elem177;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsTs_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter178)
          {
            $xfer += $iter178->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowsWithColumns_args {
  static $_TSPEC;

  public $tableName = null;
  public $rows = null;
  public $families = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'rows',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'families',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['rows'])) {
        $this->rows = $vals['rows'];
      }
      if (isset($vals['families'])) {
        $this->families = $vals['families'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowsWithColumns_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->rows = array();
            $_size179 = 0;
            $_etype182 = 0;
            $xfer += $input->readListBegin($_etype182, $_size179);
            for ($_i183 = 0; $_i183 < $_size179; ++$_i183)
            {
              $elem184 = null;
              $xfer += $input->readString($elem184);
              $this->rows []= $elem184;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->families = array();
            $_size185 = 0;
            $_etype188 = 0;
            $xfer += $input->readListBegin($_etype188, $_size185);
            for ($_i189 = 0; $_i189 < $_size185; ++$_i189)
            {
              $elem190 = null;
              $xfer += $input->readString($elem190);
              $this->families []= $elem190;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rows !== null) {
      if (!is_array($this->rows)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rows', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->rows));
        {
          foreach ($this->rows as $iter191)
          {
            $xfer += $output->writeString($iter191);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->families !== null) {
      if (!is_array($this->families)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('families', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->families));
        {
          foreach ($this->families as $iter192)
          {
            $xfer += $output->writeString($iter192);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowsWithColumns_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowsWithColumns_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size193 = 0;
            $_etype196 = 0;
            $xfer += $input->readListBegin($_etype196, $_size193);
            for ($_i197 = 0; $_i197 < $_size193; ++$_i197)
            {
              $elem198 = null;
              $elem198 = new TRowResult();
              $xfer += $elem198->read($input);
              $this->success []= $elem198;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter199)
          {
            $xfer += $iter199->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowsWithColumnsTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $rows = null;
  public $families = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'rows',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'families',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['rows'])) {
        $this->rows = $vals['rows'];
      }
      if (isset($vals['families'])) {
        $this->families = $vals['families'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowsWithColumnsTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->rows = array();
            $_size200 = 0;
            $_etype203 = 0;
            $xfer += $input->readListBegin($_etype203, $_size200);
            for ($_i204 = 0; $_i204 < $_size200; ++$_i204)
            {
              $elem205 = null;
              $xfer += $input->readString($elem205);
              $this->rows []= $elem205;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->families = array();
            $_size206 = 0;
            $_etype209 = 0;
            $xfer += $input->readListBegin($_etype209, $_size206);
            for ($_i210 = 0; $_i210 < $_size206; ++$_i210)
            {
              $elem211 = null;
              $xfer += $input->readString($elem211);
              $this->families []= $elem211;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rows !== null) {
      if (!is_array($this->rows)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rows', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->rows));
        {
          foreach ($this->rows as $iter212)
          {
            $xfer += $output->writeString($iter212);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->families !== null) {
      if (!is_array($this->families)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('families', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->families));
        {
          foreach ($this->families as $iter213)
          {
            $xfer += $output->writeString($iter213);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRowsWithColumnsTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRowsWithColumnsTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size214 = 0;
            $_etype217 = 0;
            $xfer += $input->readListBegin($_etype217, $_size214);
            for ($_i218 = 0; $_i218 < $_size214; ++$_i218)
            {
              $elem219 = null;
              $elem219 = new TRowResult();
              $xfer += $elem219->read($input);
              $this->success []= $elem219;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter220)
          {
            $xfer += $iter220->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_mutateRow_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $mutations = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'mutations',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'Mutation',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['mutations'])) {
        $this->mutations = $vals['mutations'];
      }
    }
  }

  public function getName() {
    return 'Hbase_mutateRow_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->mutations = array();
            $_size221 = 0;
            $_etype224 = 0;
            $xfer += $input->readListBegin($_etype224, $_size221);
            for ($_i225 = 0; $_i225 < $_size221; ++$_i225)
            {
              $elem226 = null;
              $elem226 = new Mutation();
              $xfer += $elem226->read($input);
              $this->mutations []= $elem226;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRow_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mutations !== null) {
      if (!is_array($this->mutations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mutations', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->mutations));
        {
          foreach ($this->mutations as $iter227)
          {
            $xfer += $iter227->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_mutateRow_result {
  static $_TSPEC;

  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_mutateRow_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRow_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_mutateRowTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $mutations = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'mutations',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'Mutation',
            ),
          ),
        4 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['mutations'])) {
        $this->mutations = $vals['mutations'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_mutateRowTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->mutations = array();
            $_size228 = 0;
            $_etype231 = 0;
            $xfer += $input->readListBegin($_etype231, $_size228);
            for ($_i232 = 0; $_i232 < $_size228; ++$_i232)
            {
              $elem233 = null;
              $elem233 = new Mutation();
              $xfer += $elem233->read($input);
              $this->mutations []= $elem233;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRowTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mutations !== null) {
      if (!is_array($this->mutations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mutations', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->mutations));
        {
          foreach ($this->mutations as $iter234)
          {
            $xfer += $iter234->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_mutateRowTs_result {
  static $_TSPEC;

  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_mutateRowTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRowTs_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_mutateRows_args {
  static $_TSPEC;

  public $tableName = null;
  public $rowBatches = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'rowBatches',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'BatchMutation',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['rowBatches'])) {
        $this->rowBatches = $vals['rowBatches'];
      }
    }
  }

  public function getName() {
    return 'Hbase_mutateRows_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->rowBatches = array();
            $_size235 = 0;
            $_etype238 = 0;
            $xfer += $input->readListBegin($_etype238, $_size235);
            for ($_i239 = 0; $_i239 < $_size235; ++$_i239)
            {
              $elem240 = null;
              $elem240 = new BatchMutation();
              $xfer += $elem240->read($input);
              $this->rowBatches []= $elem240;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRows_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rowBatches !== null) {
      if (!is_array($this->rowBatches)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rowBatches', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->rowBatches));
        {
          foreach ($this->rowBatches as $iter241)
          {
            $xfer += $iter241->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_mutateRows_result {
  static $_TSPEC;

  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_mutateRows_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRows_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_mutateRowsTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $rowBatches = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'rowBatches',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'BatchMutation',
            ),
          ),
        3 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['rowBatches'])) {
        $this->rowBatches = $vals['rowBatches'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_mutateRowsTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->rowBatches = array();
            $_size242 = 0;
            $_etype245 = 0;
            $xfer += $input->readListBegin($_etype245, $_size242);
            for ($_i246 = 0; $_i246 < $_size242; ++$_i246)
            {
              $elem247 = null;
              $elem247 = new BatchMutation();
              $xfer += $elem247->read($input);
              $this->rowBatches []= $elem247;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rowBatches !== null) {
      if (!is_array($this->rowBatches)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rowBatches', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->rowBatches));
        {
          foreach ($this->rowBatches as $iter248)
          {
            $xfer += $iter248->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_mutateRowsTs_result {
  static $_TSPEC;

  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_mutateRowsTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_checkAndMutateRow_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $columnCheck = null;
  public $valueCheck = null;
  public $mutations = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'columnCheck',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'valueCheck',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'mutations',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'Mutation',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columnCheck'])) {
        $this->columnCheck = $vals['columnCheck'];
      }
      if (isset($vals['valueCheck'])) {
        $this->valueCheck = $vals['valueCheck'];
      }
      if (isset($vals['mutations'])) {
        $this->mutations = $vals['mutations'];
      }
    }
  }

  public function getName() {
    return 'Hbase_checkAndMutateRow_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->columnCheck);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->valueCheck);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->mutations = array();
            $_size249 = 0;
            $_etype252 = 0;
            $xfer += $input->readListBegin($_etype252, $_size249);
            for ($_i253 = 0; $_i253 < $_size249; ++$_i253)
            {
              $elem254 = null;
              $elem254 = new Mutation();
              $xfer += $elem254->read($input);
              $this->mutations []= $elem254;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_checkAndMutateRow_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columnCheck !== null) {
      $xfer += $output->writeFieldBegin('columnCheck', TType::STRING, 3);
      $xfer += $output->writeString($this->columnCheck);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->valueCheck !== null) {
      $xfer += $output->writeFieldBegin('valueCheck', TType::STRING, 4);
      $xfer += $output->writeString($this->valueCheck);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mutations !== null) {
      if (!is_array($this->mutations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mutations', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->mutations));
        {
          foreach ($this->mutations as $iter255)
          {
            $xfer += $iter255->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_checkAndMutateRow_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_checkAndMutateRow_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_checkAndMutateRow_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_checkAndMutateRowTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $columnCheck = null;
  public $valueCheck = null;
  public $mutations = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'columnCheck',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'valueCheck',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'mutations',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'Mutation',
            ),
          ),
        6 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['columnCheck'])) {
        $this->columnCheck = $vals['columnCheck'];
      }
      if (isset($vals['valueCheck'])) {
        $this->valueCheck = $vals['valueCheck'];
      }
      if (isset($vals['mutations'])) {
        $this->mutations = $vals['mutations'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_checkAndMutateRowTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->columnCheck);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->valueCheck);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->mutations = array();
            $_size256 = 0;
            $_etype259 = 0;
            $xfer += $input->readListBegin($_etype259, $_size256);
            for ($_i260 = 0; $_i260 < $_size256; ++$_i260)
            {
              $elem261 = null;
              $elem261 = new Mutation();
              $xfer += $elem261->read($input);
              $this->mutations []= $elem261;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_checkAndMutateRowTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columnCheck !== null) {
      $xfer += $output->writeFieldBegin('columnCheck', TType::STRING, 3);
      $xfer += $output->writeString($this->columnCheck);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->valueCheck !== null) {
      $xfer += $output->writeFieldBegin('valueCheck', TType::STRING, 4);
      $xfer += $output->writeString($this->valueCheck);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mutations !== null) {
      if (!is_array($this->mutations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mutations', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->mutations));
        {
          foreach ($this->mutations as $iter262)
          {
            $xfer += $iter262->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 6);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_checkAndMutateRowTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::BOOL,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_checkAndMutateRowTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_checkAndMutateRowTs_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
      $xfer += $output->writeBool($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_atomicIncrement_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $column = null;
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'value',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'Hbase_atomicIncrement_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_atomicIncrement_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column !== null) {
      $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
      $xfer += $output->writeString($this->column);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I64, 4);
      $xfer += $output->writeI64($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_atomicIncrement_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I64,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_atomicIncrement_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_atomicIncrement_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I64, 0);
      $xfer += $output->writeI64($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteAll_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $column = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteAll_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAll_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column !== null) {
      $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
      $xfer += $output->writeString($this->column);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteAll_result {
  static $_TSPEC;

  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteAll_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAll_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteAllTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $column = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'column',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['column'])) {
        $this->column = $vals['column'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteAllTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->column);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->column !== null) {
      $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
      $xfer += $output->writeString($this->column);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteAllTs_result {
  static $_TSPEC;

  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteAllTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllTs_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteAllRow_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteAllRow_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllRow_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteAllRow_result {
  static $_TSPEC;

  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteAllRow_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllRow_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteAllRowTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $row = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteAllRowTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_deleteAllRowTs_result {
  static $_TSPEC;

  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_deleteAllRowTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpen_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpen_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size263 = 0;
            $_etype266 = 0;
            $xfer += $input->readListBegin($_etype266, $_size263);
            for ($_i267 = 0; $_i267 < $_size263; ++$_i267)
            {
              $elem268 = null;
              $xfer += $input->readString($elem268);
              $this->columns []= $elem268;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpen_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter269)
          {
            $xfer += $output->writeString($iter269);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpen_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpen_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpen_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithScan_args {
  static $_TSPEC;

  public $tableName = null;
  public $scan = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'scan',
          'type' => TType::STRUCT,
          'class' => 'TScan',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['scan'])) {
        $this->scan = $vals['scan'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithScan_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->scan = new TScan();
            $xfer += $this->scan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->scan !== null) {
      if (!is_object($this->scan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('scan', TType::STRUCT, 2);
      $xfer += $this->scan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithScan_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithScan_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStop_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStop_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size270 = 0;
            $_etype273 = 0;
            $xfer += $input->readListBegin($_etype273, $_size270);
            for ($_i274 = 0; $_i274 < $_size270; ++$_i274)
            {
              $elem275 = null;
              $xfer += $input->readString($elem275);
              $this->columns []= $elem275;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter276)
          {
            $xfer += $output->writeString($iter276);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStop_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStop_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithPrefix_args {
  static $_TSPEC;

  public $tableName = null;
  public $startAndPrefix = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startAndPrefix',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startAndPrefix'])) {
        $this->startAndPrefix = $vals['startAndPrefix'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithPrefix_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startAndPrefix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size277 = 0;
            $_etype280 = 0;
            $xfer += $input->readListBegin($_etype280, $_size277);
            for ($_i281 = 0; $_i281 < $_size277; ++$_i281)
            {
              $elem282 = null;
              $xfer += $input->readString($elem282);
              $this->columns []= $elem282;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startAndPrefix !== null) {
      $xfer += $output->writeFieldBegin('startAndPrefix', TType::STRING, 2);
      $xfer += $output->writeString($this->startAndPrefix);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter283)
          {
            $xfer += $output->writeString($iter283);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithPrefix_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithPrefix_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $columns = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size284 = 0;
            $_etype287 = 0;
            $xfer += $input->readListBegin($_etype287, $_size284);
            for ($_i288 = 0; $_i288 < $_size284; ++$_i288)
            {
              $elem289 = null;
              $xfer += $input->readString($elem289);
              $this->columns []= $elem289;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter290)
          {
            $xfer += $output->writeString($iter290);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size291 = 0;
            $_etype294 = 0;
            $xfer += $input->readListBegin($_etype294, $_size291);
            for ($_i295 = 0; $_i295 < $_size291; ++$_i295)
            {
              $elem296 = null;
              $xfer += $input->readString($elem296);
              $this->columns []= $elem296;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter297)
          {
            $xfer += $output->writeString($iter297);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 5);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithFilterString_args {
  static $_TSPEC;

  public $tableName = null;
  public $filterString = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'filterString',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['filterString'])) {
        $this->filterString = $vals['filterString'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithFilterString_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filterString);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithFilterString_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filterString !== null) {
      $xfer += $output->writeFieldBegin('filterString', TType::STRING, 2);
      $xfer += $output->writeString($this->filterString);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithFilterString_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithFilterString_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithFilterString_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithFilterStringTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $filterString = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'filterString',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['filterString'])) {
        $this->filterString = $vals['filterString'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithFilterStringTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filterString);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithFilterStringTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filterString !== null) {
      $xfer += $output->writeFieldBegin('filterString', TType::STRING, 2);
      $xfer += $output->writeString($this->filterString);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithFilterStringTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithFilterStringTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithFilterStringTs_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopAndFilterString_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $filterString = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'filterString',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['filterString'])) {
        $this->filterString = $vals['filterString'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopAndFilterString_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filterString);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopAndFilterString_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filterString !== null) {
      $xfer += $output->writeFieldBegin('filterString', TType::STRING, 4);
      $xfer += $output->writeString($this->filterString);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopAndFilterString_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopAndFilterString_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopAndFilterString_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopAndFilterStringTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $filterString = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'filterString',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['filterString'])) {
        $this->filterString = $vals['filterString'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopAndFilterStringTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filterString);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopAndFilterStringTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filterString !== null) {
      $xfer += $output->writeFieldBegin('filterString', TType::STRING, 4);
      $xfer += $output->writeString($this->filterString);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 6);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopAndFilterStringTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopAndFilterStringTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopAndFilterStringTs_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithIndexAndColumns_args {
  static $_TSPEC;

  public $tableName = null;
  public $columns = null;
  public $expr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithIndexAndColumns_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->columns);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithIndexAndColumns_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      $xfer += $output->writeFieldBegin('columns', TType::STRING, 2);
      $xfer += $output->writeString($this->columns);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 3);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithIndexAndColumns_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithIndexAndColumns_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithIndexAndColumns_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithIndexExpression_args {
  static $_TSPEC;

  public $tableName = null;
  public $columns = null;
  public $expr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithIndexExpression_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size298 = 0;
            $_etype301 = 0;
            $xfer += $input->readListBegin($_etype301, $_size298);
            for ($_i302 = 0; $_i302 < $_size298; ++$_i302)
            {
              $elem303 = null;
              $xfer += $input->readString($elem303);
              $this->columns []= $elem303;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithIndexExpression_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter304)
          {
            $xfer += $output->writeString($iter304);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 3);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithIndexExpression_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithIndexExpression_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithIndexExpression_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithIndexExpressionTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $columns = null;
  public $expr = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithIndexExpressionTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size305 = 0;
            $_etype308 = 0;
            $xfer += $input->readListBegin($_etype308, $_size305);
            for ($_i309 = 0; $_i309 < $_size305; ++$_i309)
            {
              $elem310 = null;
              $xfer += $input->readString($elem310);
              $this->columns []= $elem310;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithIndexExpressionTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter311)
          {
            $xfer += $output->writeString($iter311);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 3);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithIndexExpressionTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithIndexExpressionTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithIndexExpressionTs_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopAndIndexExpression_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $expr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopAndIndexExpression_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size312 = 0;
            $_etype315 = 0;
            $xfer += $input->readListBegin($_etype315, $_size312);
            for ($_i316 = 0; $_i316 < $_size312; ++$_i316)
            {
              $elem317 = null;
              $xfer += $input->readString($elem317);
              $this->columns []= $elem317;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopAndIndexExpression_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter318)
          {
            $xfer += $output->writeString($iter318);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 5);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopAndIndexExpression_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopAndIndexExpression_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopAndIndexExpression_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopAndIndexExpressionTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $expr = null;
  public $minTs = null;
  public $maxTs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'minTs',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'maxTs',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['minTs'])) {
        $this->minTs = $vals['minTs'];
      }
      if (isset($vals['maxTs'])) {
        $this->maxTs = $vals['maxTs'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopAndIndexExpressionTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size319 = 0;
            $_etype322 = 0;
            $xfer += $input->readListBegin($_etype322, $_size319);
            for ($_i323 = 0; $_i323 < $_size319; ++$_i323)
            {
              $elem324 = null;
              $xfer += $input->readString($elem324);
              $this->columns []= $elem324;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopAndIndexExpressionTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter325)
          {
            $xfer += $output->writeString($iter325);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 5);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minTs !== null) {
      $xfer += $output->writeFieldBegin('minTs', TType::I64, 6);
      $xfer += $output->writeI64($this->minTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxTs !== null) {
      $xfer += $output->writeFieldBegin('maxTs', TType::I64, 7);
      $xfer += $output->writeI64($this->maxTs);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerOpenWithStopAndIndexExpressionTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I32,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerOpenWithStopAndIndexExpressionTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopAndIndexExpressionTs_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I32, 0);
      $xfer += $output->writeI32($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_aggTopN_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $expr = null;
  public $minTs = null;
  public $maxTs = null;
  public $topnColumns = null;
  public $topnN = null;
  public $topnMaxN = null;
  public $isDesc = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'minTs',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'maxTs',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'topnColumns',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'topnN',
          'type' => TType::I32,
          ),
        10 => array(
          'var' => 'topnMaxN',
          'type' => TType::I32,
          ),
        11 => array(
          'var' => 'isDesc',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['minTs'])) {
        $this->minTs = $vals['minTs'];
      }
      if (isset($vals['maxTs'])) {
        $this->maxTs = $vals['maxTs'];
      }
      if (isset($vals['topnColumns'])) {
        $this->topnColumns = $vals['topnColumns'];
      }
      if (isset($vals['topnN'])) {
        $this->topnN = $vals['topnN'];
      }
      if (isset($vals['topnMaxN'])) {
        $this->topnMaxN = $vals['topnMaxN'];
      }
      if (isset($vals['isDesc'])) {
        $this->isDesc = $vals['isDesc'];
      }
    }
  }

  public function getName() {
    return 'Hbase_aggTopN_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size326 = 0;
            $_etype329 = 0;
            $xfer += $input->readListBegin($_etype329, $_size326);
            for ($_i330 = 0; $_i330 < $_size326; ++$_i330)
            {
              $elem331 = null;
              $xfer += $input->readString($elem331);
              $this->columns []= $elem331;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->topnColumns);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->topnN);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->topnMaxN);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isDesc);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_aggTopN_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter332)
          {
            $xfer += $output->writeString($iter332);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 5);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minTs !== null) {
      $xfer += $output->writeFieldBegin('minTs', TType::I64, 6);
      $xfer += $output->writeI64($this->minTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxTs !== null) {
      $xfer += $output->writeFieldBegin('maxTs', TType::I64, 7);
      $xfer += $output->writeI64($this->maxTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topnColumns !== null) {
      $xfer += $output->writeFieldBegin('topnColumns', TType::STRING, 8);
      $xfer += $output->writeString($this->topnColumns);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topnN !== null) {
      $xfer += $output->writeFieldBegin('topnN', TType::I32, 9);
      $xfer += $output->writeI32($this->topnN);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->topnMaxN !== null) {
      $xfer += $output->writeFieldBegin('topnMaxN', TType::I32, 10);
      $xfer += $output->writeI32($this->topnMaxN);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isDesc !== null) {
      $xfer += $output->writeFieldBegin('isDesc', TType::BOOL, 11);
      $xfer += $output->writeBool($this->isDesc);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_aggTopN_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::MAP,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::MAP,
            'ktype' => TType::STRING,
            'vtype' => TType::I32,
            'key' => array(
              'type' => TType::STRING,
            ),
            'val' => array(
              'type' => TType::I32,
              ),
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_aggTopN_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size333 = 0;
            $_ktype334 = 0;
            $_vtype335 = 0;
            $xfer += $input->readMapBegin($_ktype334, $_vtype335, $_size333);
            for ($_i337 = 0; $_i337 < $_size333; ++$_i337)
            {
              $key338 = '';
              $val339 = array();
              $xfer += $input->readString($key338);
              $val339 = array();
              $_size340 = 0;
              $_ktype341 = 0;
              $_vtype342 = 0;
              $xfer += $input->readMapBegin($_ktype341, $_vtype342, $_size340);
              for ($_i344 = 0; $_i344 < $_size340; ++$_i344)
              {
                $key345 = '';
                $val346 = 0;
                $xfer += $input->readString($key345);
                $xfer += $input->readI32($val346);
                $val339[$key345] = $val346;
              }
              $xfer += $input->readMapEnd();
              $this->success[$key338] = $val339;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_aggTopN_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
      {
        $output->writeMapBegin(TType::STRING, TType::MAP, count($this->success));
        {
          foreach ($this->success as $kiter347 => $viter348)
          {
            $xfer += $output->writeString($kiter347);
            {
              $output->writeMapBegin(TType::STRING, TType::I32, count($viter348));
              {
                foreach ($viter348 as $kiter349 => $viter350)
                {
                  $xfer += $output->writeString($kiter349);
                  $xfer += $output->writeI32($viter350);
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_aggRowNum_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $expr = null;
  public $minTs = null;
  public $maxTs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'minTs',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'maxTs',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['minTs'])) {
        $this->minTs = $vals['minTs'];
      }
      if (isset($vals['maxTs'])) {
        $this->maxTs = $vals['maxTs'];
      }
    }
  }

  public function getName() {
    return 'Hbase_aggRowNum_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size351 = 0;
            $_etype354 = 0;
            $xfer += $input->readListBegin($_etype354, $_size351);
            for ($_i355 = 0; $_i355 < $_size351; ++$_i355)
            {
              $elem356 = null;
              $xfer += $input->readString($elem356);
              $this->columns []= $elem356;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_aggRowNum_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter357)
          {
            $xfer += $output->writeString($iter357);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 5);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minTs !== null) {
      $xfer += $output->writeFieldBegin('minTs', TType::I64, 6);
      $xfer += $output->writeI64($this->minTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxTs !== null) {
      $xfer += $output->writeFieldBegin('maxTs', TType::I64, 7);
      $xfer += $output->writeI64($this->maxTs);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_aggRowNum_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::I64,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_aggRowNum_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_aggRowNum_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::I64, 0);
      $xfer += $output->writeI64($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_aggFacetingByTimestamp_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $expr = null;
  public $minTs = null;
  public $maxTs = null;
  public $startTs = null;
  public $endTs = null;
  public $intervalTs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'minTs',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'maxTs',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'startTs',
          'type' => TType::I64,
          ),
        9 => array(
          'var' => 'endTs',
          'type' => TType::I64,
          ),
        10 => array(
          'var' => 'intervalTs',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['minTs'])) {
        $this->minTs = $vals['minTs'];
      }
      if (isset($vals['maxTs'])) {
        $this->maxTs = $vals['maxTs'];
      }
      if (isset($vals['startTs'])) {
        $this->startTs = $vals['startTs'];
      }
      if (isset($vals['endTs'])) {
        $this->endTs = $vals['endTs'];
      }
      if (isset($vals['intervalTs'])) {
        $this->intervalTs = $vals['intervalTs'];
      }
    }
  }

  public function getName() {
    return 'Hbase_aggFacetingByTimestamp_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size358 = 0;
            $_etype361 = 0;
            $xfer += $input->readListBegin($_etype361, $_size358);
            for ($_i362 = 0; $_i362 < $_size358; ++$_i362)
            {
              $elem363 = null;
              $xfer += $input->readString($elem363);
              $this->columns []= $elem363;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->endTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->intervalTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_aggFacetingByTimestamp_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter364)
          {
            $xfer += $output->writeString($iter364);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 5);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minTs !== null) {
      $xfer += $output->writeFieldBegin('minTs', TType::I64, 6);
      $xfer += $output->writeI64($this->minTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxTs !== null) {
      $xfer += $output->writeFieldBegin('maxTs', TType::I64, 7);
      $xfer += $output->writeI64($this->maxTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startTs !== null) {
      $xfer += $output->writeFieldBegin('startTs', TType::I64, 8);
      $xfer += $output->writeI64($this->startTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endTs !== null) {
      $xfer += $output->writeFieldBegin('endTs', TType::I64, 9);
      $xfer += $output->writeI64($this->endTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->intervalTs !== null) {
      $xfer += $output->writeFieldBegin('intervalTs', TType::I64, 10);
      $xfer += $output->writeI64($this->intervalTs);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_aggFacetingByTimestamp_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_aggFacetingByTimestamp_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_aggFacetingByTimestamp_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getTableIndexDesc_args {
  static $_TSPEC;

  public $tableName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getTableIndexDesc_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableIndexDesc_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getTableIndexDesc_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getTableIndexDesc_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::MAP) {
            $this->success = array();
            $_size365 = 0;
            $_ktype366 = 0;
            $_vtype367 = 0;
            $xfer += $input->readMapBegin($_ktype366, $_vtype367, $_size365);
            for ($_i369 = 0; $_i369 < $_size365; ++$_i369)
            {
              $key370 = '';
              $val371 = '';
              $xfer += $input->readString($key370);
              $xfer += $input->readString($val371);
              $this->success[$key370] = $val371;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getTableIndexDesc_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->success));
        {
          foreach ($this->success as $kiter372 => $viter373)
          {
            $xfer += $output->writeString($kiter372);
            $xfer += $output->writeString($viter373);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithScan_args {
  static $_TSPEC;

  public $tableName = null;
  public $scan = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'scan',
          'type' => TType::STRUCT,
          'class' => 'TScan',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['scan'])) {
        $this->scan = $vals['scan'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithScan_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->scan = new TScan();
            $xfer += $this->scan->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithScan_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->scan !== null) {
      if (!is_object($this->scan)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('scan', TType::STRUCT, 2);
      $xfer += $this->scan->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithScan_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithScan_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size374 = 0;
            $_etype377 = 0;
            $xfer += $input->readListBegin($_etype377, $_size374);
            for ($_i378 = 0; $_i378 < $_size374; ++$_i378)
            {
              $elem379 = null;
              $elem379 = new TRowResult();
              $xfer += $elem379->read($input);
              $this->success []= $elem379;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithScan_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter380)
          {
            $xfer += $iter380->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithStop_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithStop_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size381 = 0;
            $_etype384 = 0;
            $xfer += $input->readListBegin($_etype384, $_size381);
            for ($_i385 = 0; $_i385 < $_size381; ++$_i385)
            {
              $elem386 = null;
              $xfer += $input->readString($elem386);
              $this->columns []= $elem386;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithStop_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter387)
          {
            $xfer += $output->writeString($iter387);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithStop_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithStop_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size388 = 0;
            $_etype391 = 0;
            $xfer += $input->readListBegin($_etype391, $_size388);
            for ($_i392 = 0; $_i392 < $_size388; ++$_i392)
            {
              $elem393 = null;
              $elem393 = new TRowResult();
              $xfer += $elem393->read($input);
              $this->success []= $elem393;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithStop_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter394)
          {
            $xfer += $iter394->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithStopTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithStopTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size395 = 0;
            $_etype398 = 0;
            $xfer += $input->readListBegin($_etype398, $_size395);
            for ($_i399 = 0; $_i399 < $_size395; ++$_i399)
            {
              $elem400 = null;
              $xfer += $input->readString($elem400);
              $this->columns []= $elem400;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithStopTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter401)
          {
            $xfer += $output->writeString($iter401);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 5);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithStopTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithStopTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size402 = 0;
            $_etype405 = 0;
            $xfer += $input->readListBegin($_etype405, $_size402);
            for ($_i406 = 0; $_i406 < $_size402; ++$_i406)
            {
              $elem407 = null;
              $elem407 = new TRowResult();
              $xfer += $elem407->read($input);
              $this->success []= $elem407;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithStopTs_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter408)
          {
            $xfer += $iter408->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithIndexExpression_args {
  static $_TSPEC;

  public $tableName = null;
  public $columns = null;
  public $expr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithIndexExpression_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size409 = 0;
            $_etype412 = 0;
            $xfer += $input->readListBegin($_etype412, $_size409);
            for ($_i413 = 0; $_i413 < $_size409; ++$_i413)
            {
              $elem414 = null;
              $xfer += $input->readString($elem414);
              $this->columns []= $elem414;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithIndexExpression_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter415)
          {
            $xfer += $output->writeString($iter415);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 3);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithIndexExpression_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithIndexExpression_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size416 = 0;
            $_etype419 = 0;
            $xfer += $input->readListBegin($_etype419, $_size416);
            for ($_i420 = 0; $_i420 < $_size416; ++$_i420)
            {
              $elem421 = null;
              $elem421 = new TRowResult();
              $xfer += $elem421->read($input);
              $this->success []= $elem421;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithIndexExpression_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter422)
          {
            $xfer += $iter422->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithStopAndIndexExpression_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $expr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithStopAndIndexExpression_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size423 = 0;
            $_etype426 = 0;
            $xfer += $input->readListBegin($_etype426, $_size423);
            for ($_i427 = 0; $_i427 < $_size423; ++$_i427)
            {
              $elem428 = null;
              $xfer += $input->readString($elem428);
              $this->columns []= $elem428;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithStopAndIndexExpression_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter429)
          {
            $xfer += $output->writeString($iter429);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 5);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithStopAndIndexExpression_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithStopAndIndexExpression_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size430 = 0;
            $_etype433 = 0;
            $xfer += $input->readListBegin($_etype433, $_size430);
            for ($_i434 = 0; $_i434 < $_size430; ++$_i434)
            {
              $elem435 = null;
              $elem435 = new TRowResult();
              $xfer += $elem435->read($input);
              $this->success []= $elem435;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithStopAndIndexExpression_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter436)
          {
            $xfer += $iter436->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithIndexExpressionTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $columns = null;
  public $expr = null;
  public $timestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'timestamp',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithIndexExpressionTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size437 = 0;
            $_etype440 = 0;
            $xfer += $input->readListBegin($_etype440, $_size437);
            for ($_i441 = 0; $_i441 < $_size437; ++$_i441)
            {
              $elem442 = null;
              $xfer += $input->readString($elem442);
              $this->columns []= $elem442;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithIndexExpressionTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter443)
          {
            $xfer += $output->writeString($iter443);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 3);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithIndexExpressionTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithIndexExpressionTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size444 = 0;
            $_etype447 = 0;
            $xfer += $input->readListBegin($_etype447, $_size444);
            for ($_i448 = 0; $_i448 < $_size444; ++$_i448)
            {
              $elem449 = null;
              $elem449 = new TRowResult();
              $xfer += $elem449->read($input);
              $this->success []= $elem449;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithIndexExpressionTs_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter450)
          {
            $xfer += $iter450->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithStopAndIndexExpressionTs_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $expr = null;
  public $minTs = null;
  public $maxTs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'minTs',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'maxTs',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['minTs'])) {
        $this->minTs = $vals['minTs'];
      }
      if (isset($vals['maxTs'])) {
        $this->maxTs = $vals['maxTs'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithStopAndIndexExpressionTs_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size451 = 0;
            $_etype454 = 0;
            $xfer += $input->readListBegin($_etype454, $_size451);
            for ($_i455 = 0; $_i455 < $_size451; ++$_i455)
            {
              $elem456 = null;
              $xfer += $input->readString($elem456);
              $this->columns []= $elem456;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithStopAndIndexExpressionTs_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter457)
          {
            $xfer += $output->writeString($iter457);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 5);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minTs !== null) {
      $xfer += $output->writeFieldBegin('minTs', TType::I64, 6);
      $xfer += $output->writeI64($this->minTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxTs !== null) {
      $xfer += $output->writeFieldBegin('maxTs', TType::I64, 7);
      $xfer += $output->writeI64($this->maxTs);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_miniScanWithStopAndIndexExpressionTs_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_miniScanWithStopAndIndexExpressionTs_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size458 = 0;
            $_etype461 = 0;
            $xfer += $input->readListBegin($_etype461, $_size458);
            for ($_i462 = 0; $_i462 < $_size458; ++$_i462)
            {
              $elem463 = null;
              $elem463 = new TRowResult();
              $xfer += $elem463->read($input);
              $this->success []= $elem463;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_miniScanWithStopAndIndexExpressionTs_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter464)
          {
            $xfer += $iter464->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_searchMaxScoreResult_args {
  static $_TSPEC;

  public $tableName = null;
  public $startRow = null;
  public $stopRow = null;
  public $columns = null;
  public $expr = null;
  public $count = null;
  public $minTs = null;
  public $maxTs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tableName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'startRow',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stopRow',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'columns',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'expr',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'count',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'minTs',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'maxTs',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tableName'])) {
        $this->tableName = $vals['tableName'];
      }
      if (isset($vals['startRow'])) {
        $this->startRow = $vals['startRow'];
      }
      if (isset($vals['stopRow'])) {
        $this->stopRow = $vals['stopRow'];
      }
      if (isset($vals['columns'])) {
        $this->columns = $vals['columns'];
      }
      if (isset($vals['expr'])) {
        $this->expr = $vals['expr'];
      }
      if (isset($vals['count'])) {
        $this->count = $vals['count'];
      }
      if (isset($vals['minTs'])) {
        $this->minTs = $vals['minTs'];
      }
      if (isset($vals['maxTs'])) {
        $this->maxTs = $vals['maxTs'];
      }
    }
  }

  public function getName() {
    return 'Hbase_searchMaxScoreResult_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tableName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stopRow);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->columns = array();
            $_size465 = 0;
            $_etype468 = 0;
            $xfer += $input->readListBegin($_etype468, $_size465);
            for ($_i469 = 0; $_i469 < $_size465; ++$_i469)
            {
              $elem470 = null;
              $xfer += $input->readString($elem470);
              $this->columns []= $elem470;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expr);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->count);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxTs);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_searchMaxScoreResult_args');
    if ($this->tableName !== null) {
      $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
      $xfer += $output->writeString($this->tableName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startRow !== null) {
      $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
      $xfer += $output->writeString($this->startRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stopRow !== null) {
      $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
      $xfer += $output->writeString($this->stopRow);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->columns !== null) {
      if (!is_array($this->columns)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columns', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->columns));
        {
          foreach ($this->columns as $iter471)
          {
            $xfer += $output->writeString($iter471);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expr !== null) {
      $xfer += $output->writeFieldBegin('expr', TType::STRING, 5);
      $xfer += $output->writeString($this->expr);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->count !== null) {
      $xfer += $output->writeFieldBegin('count', TType::I32, 6);
      $xfer += $output->writeI32($this->count);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minTs !== null) {
      $xfer += $output->writeFieldBegin('minTs', TType::I64, 7);
      $xfer += $output->writeI64($this->minTs);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxTs !== null) {
      $xfer += $output->writeFieldBegin('maxTs', TType::I64, 8);
      $xfer += $output->writeI64($this->maxTs);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_searchMaxScoreResult_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_searchMaxScoreResult_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size472 = 0;
            $_etype475 = 0;
            $xfer += $input->readListBegin($_etype475, $_size472);
            for ($_i476 = 0; $_i476 < $_size472; ++$_i476)
            {
              $elem477 = null;
              $elem477 = new TRowResult();
              $xfer += $elem477->read($input);
              $this->success []= $elem477;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_searchMaxScoreResult_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter478)
          {
            $xfer += $iter478->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerGet_args {
  static $_TSPEC;

  public $id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerGet_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGet_args');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I32, 1);
      $xfer += $output->writeI32($this->id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerGet_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerGet_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size479 = 0;
            $_etype482 = 0;
            $xfer += $input->readListBegin($_etype482, $_size479);
            for ($_i483 = 0; $_i483 < $_size479; ++$_i483)
            {
              $elem484 = null;
              $elem484 = new TRowResult();
              $xfer += $elem484->read($input);
              $this->success []= $elem484;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGet_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter485)
          {
            $xfer += $iter485->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerGetList_args {
  static $_TSPEC;

  public $id = null;
  public $nbRows = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'nbRows',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['nbRows'])) {
        $this->nbRows = $vals['nbRows'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerGetList_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->nbRows);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGetList_args');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I32, 1);
      $xfer += $output->writeI32($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nbRows !== null) {
      $xfer += $output->writeFieldBegin('nbRows', TType::I32, 2);
      $xfer += $output->writeI32($this->nbRows);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerGetList_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'TRowResult',
            ),
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerGetList_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size486 = 0;
            $_etype489 = 0;
            $xfer += $input->readListBegin($_etype489, $_size486);
            for ($_i490 = 0; $_i490 < $_size486; ++$_i490)
            {
              $elem491 = null;
              $elem491 = new TRowResult();
              $xfer += $elem491->read($input);
              $this->success []= $elem491;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGetList_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter492)
          {
            $xfer += $iter492->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerGetListByJson_args {
  static $_TSPEC;

  public $id = null;
  public $nbRows = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'nbRows',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['nbRows'])) {
        $this->nbRows = $vals['nbRows'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerGetListByJson_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->nbRows);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGetListByJson_args');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I32, 1);
      $xfer += $output->writeI32($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nbRows !== null) {
      $xfer += $output->writeFieldBegin('nbRows', TType::I32, 2);
      $xfer += $output->writeI32($this->nbRows);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerGetListByJson_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRING,
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerGetListByJson_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->success);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerGetListByJson_result');
    if ($this->success !== null) {
      $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
      $xfer += $output->writeString($this->success);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerClose_args {
  static $_TSPEC;

  public $id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerClose_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerClose_args');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I32, 1);
      $xfer += $output->writeI32($this->id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_scannerClose_result {
  static $_TSPEC;

  public $io = null;
  public $ia = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        2 => array(
          'var' => 'ia',
          'type' => TType::STRUCT,
          'class' => 'IllegalArgument',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
      if (isset($vals['ia'])) {
        $this->ia = $vals['ia'];
      }
    }
  }

  public function getName() {
    return 'Hbase_scannerClose_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ia = new IllegalArgument();
            $xfer += $this->ia->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_scannerClose_result');
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ia !== null) {
      $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
      $xfer += $this->ia->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRegionInfo_args {
  static $_TSPEC;

  public $row = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'row',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['row'])) {
        $this->row = $vals['row'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRegionInfo_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->row);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRegionInfo_args');
    if ($this->row !== null) {
      $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
      $xfer += $output->writeString($this->row);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_getRegionInfo_result {
  static $_TSPEC;

  public $success = null;
  public $io = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::STRUCT,
          'class' => 'TRegionInfo',
          ),
        1 => array(
          'var' => 'io',
          'type' => TType::STRUCT,
          'class' => 'IOError',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['io'])) {
        $this->io = $vals['io'];
      }
    }
  }

  public function getName() {
    return 'Hbase_getRegionInfo_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::STRUCT) {
            $this->success = new TRegionInfo();
            $xfer += $this->success->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->io = new IOError();
            $xfer += $this->io->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_getRegionInfo_result');
    if ($this->success !== null) {
      if (!is_object($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
      $xfer += $this->success->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->io !== null) {
      $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
      $xfer += $this->io->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreBatchRead_args {
  static $_TSPEC;

  public $columnstore_list = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'columnstore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnStore',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['columnstore_list'])) {
        $this->columnstore_list = $vals['columnstore_list'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreBatchRead_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->columnstore_list = array();
            $_size493 = 0;
            $_etype496 = 0;
            $xfer += $input->readListBegin($_etype496, $_size493);
            for ($_i497 = 0; $_i497 < $_size493; ++$_i497)
            {
              $elem498 = null;
              $elem498 = new ColumnStore();
              $xfer += $elem498->read($input);
              $this->columnstore_list []= $elem498;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreBatchRead_args');
    if ($this->columnstore_list !== null) {
      if (!is_array($this->columnstore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columnstore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columnstore_list));
        {
          foreach ($this->columnstore_list as $iter499)
          {
            $xfer += $iter499->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreBatchRead_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnStore',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreBatchRead_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size500 = 0;
            $_etype503 = 0;
            $xfer += $input->readListBegin($_etype503, $_size500);
            for ($_i504 = 0; $_i504 < $_size500; ++$_i504)
            {
              $elem505 = null;
              $elem505 = new ColumnStore();
              $xfer += $elem505->read($input);
              $this->success []= $elem505;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreBatchRead_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter506)
          {
            $xfer += $iter506->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreBatchReadDigest_args {
  static $_TSPEC;

  public $columnstore_list = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'columnstore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnStore',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['columnstore_list'])) {
        $this->columnstore_list = $vals['columnstore_list'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreBatchReadDigest_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->columnstore_list = array();
            $_size507 = 0;
            $_etype510 = 0;
            $xfer += $input->readListBegin($_etype510, $_size507);
            for ($_i511 = 0; $_i511 < $_size507; ++$_i511)
            {
              $elem512 = null;
              $elem512 = new ColumnStore();
              $xfer += $elem512->read($input);
              $this->columnstore_list []= $elem512;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreBatchReadDigest_args');
    if ($this->columnstore_list !== null) {
      if (!is_array($this->columnstore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columnstore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columnstore_list));
        {
          foreach ($this->columnstore_list as $iter513)
          {
            $xfer += $iter513->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreBatchReadDigest_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnStore',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreBatchReadDigest_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size514 = 0;
            $_etype517 = 0;
            $xfer += $input->readListBegin($_etype517, $_size514);
            for ($_i518 = 0; $_i518 < $_size514; ++$_i518)
            {
              $elem519 = null;
              $elem519 = new ColumnStore();
              $xfer += $elem519->read($input);
              $this->success []= $elem519;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreBatchReadDigest_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter520)
          {
            $xfer += $iter520->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreBatchWrite_args {
  static $_TSPEC;

  public $columnstore_list = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'columnstore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'ColumnStore',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['columnstore_list'])) {
        $this->columnstore_list = $vals['columnstore_list'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreBatchWrite_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->columnstore_list = array();
            $_size521 = 0;
            $_etype524 = 0;
            $xfer += $input->readListBegin($_etype524, $_size521);
            for ($_i525 = 0; $_i525 < $_size521; ++$_i525)
            {
              $elem526 = null;
              $elem526 = new ColumnStore();
              $xfer += $elem526->read($input);
              $this->columnstore_list []= $elem526;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreBatchWrite_args');
    if ($this->columnstore_list !== null) {
      if (!is_array($this->columnstore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('columnstore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->columnstore_list));
        {
          foreach ($this->columnstore_list as $iter527)
          {
            $xfer += $iter527->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreBatchWrite_result {
  static $_TSPEC;

  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreBatchWrite_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreBatchWrite_result');
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreMultiRead_args {
  static $_TSPEC;

  public $keystore_list = null;
  public $consistency_level = 2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keystore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keystore_list'])) {
        $this->keystore_list = $vals['keystore_list'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreMultiRead_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keystore_list = array();
            $_size528 = 0;
            $_etype531 = 0;
            $xfer += $input->readListBegin($_etype531, $_size528);
            for ($_i532 = 0; $_i532 < $_size528; ++$_i532)
            {
              $elem533 = null;
              $elem533 = new KeyStore();
              $xfer += $elem533->read($input);
              $this->keystore_list []= $elem533;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->consistency_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreMultiRead_args');
    if ($this->keystore_list !== null) {
      if (!is_array($this->keystore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keystore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->keystore_list));
        {
          foreach ($this->keystore_list as $iter534)
          {
            $xfer += $iter534->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consistency_level !== null) {
      $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
      $xfer += $output->writeI32($this->consistency_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreMultiRead_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreMultiRead_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size535 = 0;
            $_etype538 = 0;
            $xfer += $input->readListBegin($_etype538, $_size535);
            for ($_i539 = 0; $_i539 < $_size535; ++$_i539)
            {
              $elem540 = null;
              $elem540 = new KeyStore();
              $xfer += $elem540->read($input);
              $this->success []= $elem540;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreMultiRead_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter541)
          {
            $xfer += $iter541->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreMultiReadDigest_args {
  static $_TSPEC;

  public $keystore_list = null;
  public $consistency_level = 2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keystore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keystore_list'])) {
        $this->keystore_list = $vals['keystore_list'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreMultiReadDigest_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keystore_list = array();
            $_size542 = 0;
            $_etype545 = 0;
            $xfer += $input->readListBegin($_etype545, $_size542);
            for ($_i546 = 0; $_i546 < $_size542; ++$_i546)
            {
              $elem547 = null;
              $elem547 = new KeyStore();
              $xfer += $elem547->read($input);
              $this->keystore_list []= $elem547;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->consistency_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreMultiReadDigest_args');
    if ($this->keystore_list !== null) {
      if (!is_array($this->keystore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keystore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->keystore_list));
        {
          foreach ($this->keystore_list as $iter548)
          {
            $xfer += $iter548->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consistency_level !== null) {
      $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
      $xfer += $output->writeI32($this->consistency_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreMultiReadDigest_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreMultiReadDigest_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size549 = 0;
            $_etype552 = 0;
            $xfer += $input->readListBegin($_etype552, $_size549);
            for ($_i553 = 0; $_i553 < $_size549; ++$_i553)
            {
              $elem554 = null;
              $elem554 = new KeyStore();
              $xfer += $elem554->read($input);
              $this->success []= $elem554;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreMultiReadDigest_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter555)
          {
            $xfer += $iter555->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreMultiWrite_args {
  static $_TSPEC;

  public $keystore_list = null;
  public $consistency_level = 2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keystore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keystore_list'])) {
        $this->keystore_list = $vals['keystore_list'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreMultiWrite_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keystore_list = array();
            $_size556 = 0;
            $_etype559 = 0;
            $xfer += $input->readListBegin($_etype559, $_size556);
            for ($_i560 = 0; $_i560 < $_size556; ++$_i560)
            {
              $elem561 = null;
              $elem561 = new KeyStore();
              $xfer += $elem561->read($input);
              $this->keystore_list []= $elem561;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->consistency_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreMultiWrite_args');
    if ($this->keystore_list !== null) {
      if (!is_array($this->keystore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keystore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->keystore_list));
        {
          foreach ($this->keystore_list as $iter562)
          {
            $xfer += $iter562->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consistency_level !== null) {
      $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
      $xfer += $output->writeI32($this->consistency_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreMultiWrite_result {
  static $_TSPEC;

  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreMultiWrite_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreMultiWrite_result');
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreMultiDelete_args {
  static $_TSPEC;

  public $keystore_list = null;
  public $consistency_level = 2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keystore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keystore_list'])) {
        $this->keystore_list = $vals['keystore_list'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreMultiDelete_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keystore_list = array();
            $_size563 = 0;
            $_etype566 = 0;
            $xfer += $input->readListBegin($_etype566, $_size563);
            for ($_i567 = 0; $_i567 < $_size563; ++$_i567)
            {
              $elem568 = null;
              $elem568 = new KeyStore();
              $xfer += $elem568->read($input);
              $this->keystore_list []= $elem568;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->consistency_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreMultiDelete_args');
    if ($this->keystore_list !== null) {
      if (!is_array($this->keystore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keystore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->keystore_list));
        {
          foreach ($this->keystore_list as $iter569)
          {
            $xfer += $iter569->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consistency_level !== null) {
      $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
      $xfer += $output->writeI32($this->consistency_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_QstoreMultiDelete_result {
  static $_TSPEC;

  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_QstoreMultiDelete_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_QstoreMultiDelete_result');
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_InnerMultiRead_args {
  static $_TSPEC;

  public $keystore_list = null;
  public $consistency_level = 2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keystore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keystore_list'])) {
        $this->keystore_list = $vals['keystore_list'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Hbase_InnerMultiRead_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keystore_list = array();
            $_size570 = 0;
            $_etype573 = 0;
            $xfer += $input->readListBegin($_etype573, $_size570);
            for ($_i574 = 0; $_i574 < $_size570; ++$_i574)
            {
              $elem575 = null;
              $elem575 = new KeyStore();
              $xfer += $elem575->read($input);
              $this->keystore_list []= $elem575;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->consistency_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_InnerMultiRead_args');
    if ($this->keystore_list !== null) {
      if (!is_array($this->keystore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keystore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->keystore_list));
        {
          foreach ($this->keystore_list as $iter576)
          {
            $xfer += $iter576->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consistency_level !== null) {
      $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
      $xfer += $output->writeI32($this->consistency_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_InnerMultiRead_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_InnerMultiRead_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size577 = 0;
            $_etype580 = 0;
            $xfer += $input->readListBegin($_etype580, $_size577);
            for ($_i581 = 0; $_i581 < $_size577; ++$_i581)
            {
              $elem582 = null;
              $elem582 = new KeyStore();
              $xfer += $elem582->read($input);
              $this->success []= $elem582;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_InnerMultiRead_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter583)
          {
            $xfer += $iter583->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_InnerMultiReadDigest_args {
  static $_TSPEC;

  public $keystore_list = null;
  public $consistency_level = 2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keystore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keystore_list'])) {
        $this->keystore_list = $vals['keystore_list'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Hbase_InnerMultiReadDigest_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keystore_list = array();
            $_size584 = 0;
            $_etype587 = 0;
            $xfer += $input->readListBegin($_etype587, $_size584);
            for ($_i588 = 0; $_i588 < $_size584; ++$_i588)
            {
              $elem589 = null;
              $elem589 = new KeyStore();
              $xfer += $elem589->read($input);
              $this->keystore_list []= $elem589;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->consistency_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_InnerMultiReadDigest_args');
    if ($this->keystore_list !== null) {
      if (!is_array($this->keystore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keystore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->keystore_list));
        {
          foreach ($this->keystore_list as $iter590)
          {
            $xfer += $iter590->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consistency_level !== null) {
      $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
      $xfer += $output->writeI32($this->consistency_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_InnerMultiReadDigest_result {
  static $_TSPEC;

  public $success = null;
  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        0 => array(
          'var' => 'success',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['success'])) {
        $this->success = $vals['success'];
      }
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_InnerMultiReadDigest_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 0:
          if ($ftype == TType::LST) {
            $this->success = array();
            $_size591 = 0;
            $_etype594 = 0;
            $xfer += $input->readListBegin($_etype594, $_size591);
            for ($_i595 = 0; $_i595 < $_size591; ++$_i595)
            {
              $elem596 = null;
              $elem596 = new KeyStore();
              $xfer += $elem596->read($input);
              $this->success []= $elem596;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_InnerMultiReadDigest_result');
    if ($this->success !== null) {
      if (!is_array($this->success)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('success', TType::LST, 0);
      {
        $output->writeListBegin(TType::STRUCT, count($this->success));
        {
          foreach ($this->success as $iter597)
          {
            $xfer += $iter597->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_InnerMultiWrite_args {
  static $_TSPEC;

  public $keystore_list = null;
  public $consistency_level = 2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keystore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keystore_list'])) {
        $this->keystore_list = $vals['keystore_list'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Hbase_InnerMultiWrite_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keystore_list = array();
            $_size598 = 0;
            $_etype601 = 0;
            $xfer += $input->readListBegin($_etype601, $_size598);
            for ($_i602 = 0; $_i602 < $_size598; ++$_i602)
            {
              $elem603 = null;
              $elem603 = new KeyStore();
              $xfer += $elem603->read($input);
              $this->keystore_list []= $elem603;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->consistency_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_InnerMultiWrite_args');
    if ($this->keystore_list !== null) {
      if (!is_array($this->keystore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keystore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->keystore_list));
        {
          foreach ($this->keystore_list as $iter604)
          {
            $xfer += $iter604->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consistency_level !== null) {
      $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
      $xfer += $output->writeI32($this->consistency_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_InnerMultiWrite_result {
  static $_TSPEC;

  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_InnerMultiWrite_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_InnerMultiWrite_result');
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_TransferMultiWrite_args {
  static $_TSPEC;

  public $keystore_list = null;
  public $consistency_level = 2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keystore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keystore_list'])) {
        $this->keystore_list = $vals['keystore_list'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Hbase_TransferMultiWrite_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keystore_list = array();
            $_size605 = 0;
            $_etype608 = 0;
            $xfer += $input->readListBegin($_etype608, $_size605);
            for ($_i609 = 0; $_i609 < $_size605; ++$_i609)
            {
              $elem610 = null;
              $elem610 = new KeyStore();
              $xfer += $elem610->read($input);
              $this->keystore_list []= $elem610;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->consistency_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_TransferMultiWrite_args');
    if ($this->keystore_list !== null) {
      if (!is_array($this->keystore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keystore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->keystore_list));
        {
          foreach ($this->keystore_list as $iter611)
          {
            $xfer += $iter611->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consistency_level !== null) {
      $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
      $xfer += $output->writeI32($this->consistency_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_TransferMultiWrite_result {
  static $_TSPEC;

  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_TransferMultiWrite_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_TransferMultiWrite_result');
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_InnerMultiDelete_args {
  static $_TSPEC;

  public $keystore_list = null;
  public $consistency_level = 2;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'keystore_list',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'KeyStore',
            ),
          ),
        2 => array(
          'var' => 'consistency_level',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['keystore_list'])) {
        $this->keystore_list = $vals['keystore_list'];
      }
      if (isset($vals['consistency_level'])) {
        $this->consistency_level = $vals['consistency_level'];
      }
    }
  }

  public function getName() {
    return 'Hbase_InnerMultiDelete_args';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->keystore_list = array();
            $_size612 = 0;
            $_etype615 = 0;
            $xfer += $input->readListBegin($_etype615, $_size612);
            for ($_i616 = 0; $_i616 < $_size612; ++$_i616)
            {
              $elem617 = null;
              $elem617 = new KeyStore();
              $xfer += $elem617->read($input);
              $this->keystore_list []= $elem617;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->consistency_level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_InnerMultiDelete_args');
    if ($this->keystore_list !== null) {
      if (!is_array($this->keystore_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('keystore_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->keystore_list));
        {
          foreach ($this->keystore_list as $iter618)
          {
            $xfer += $iter618->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consistency_level !== null) {
      $xfer += $output->writeFieldBegin('consistency_level', TType::I32, 2);
      $xfer += $output->writeI32($this->consistency_level);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Hbase_InnerMultiDelete_result {
  static $_TSPEC;

  public $qe = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'qe',
          'type' => TType::STRUCT,
          'class' => 'QstoreException',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['qe'])) {
        $this->qe = $vals['qe'];
      }
    }
  }

  public function getName() {
    return 'Hbase_InnerMultiDelete_result';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->qe = new QstoreException();
            $xfer += $this->qe->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hbase_InnerMultiDelete_result');
    if ($this->qe !== null) {
      $xfer += $output->writeFieldBegin('qe', TType::STRUCT, 1);
      $xfer += $this->qe->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

?>
